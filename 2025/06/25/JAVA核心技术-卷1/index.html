
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>JAVA核心技术 卷1 | NJUShinchan&#39;s Nest</title>
    <meta name="author" content="Yonghong Lin" />
    <meta name="description" content="And let your spirit dance with the world’s endless possibilities." />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="https://s4.zstatic.net/ajax/libs/gitalk/1.8.0/gitalk.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/gitalk/1.8.0/gitalk.min.css" />


<script src="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.min.css" />
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline-meta.min.css" />


<script src="https://s4.zstatic.net/ajax/libs/twikoo/1.6.31/twikoo.all.min.js"></script>



<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>NJUSHINCHAN&#39;S NEST</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;NJUSHINCHAN&#39;S NEST</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>JAVA核心技术 卷1</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/6/25
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>作者：Cay S.Horstmann</p>
<p>介绍了JAVA语言的基本概念以及用户界面程序设计的基础知识</p>
<p>Learn <a target="_blank" rel="noopener" href="https://horstmann.com/corejava/">Java 核心技术</a></p>
<span id="more"></span>

<h1 id="第一章-JAVA程序设计概述"><a href="#第一章-JAVA程序设计概述" class="headerlink" title="第一章 JAVA程序设计概述"></a>第一章 JAVA程序设计概述</h1><h2 id="1-1-JAVA程序设计平台"><a href="#1-1-JAVA程序设计平台" class="headerlink" title="1.1 JAVA程序设计平台"></a>1.1 JAVA程序设计平台</h2><p>JAVA是一个完整的平台，有一个<strong>庞大丰富</strong>的库，其中包含了大量可重用的代码，还有一个提供诸如安全性、跨操作系统的可移植性以及自动垃圾收集等服务的执行环境。</p>
<h2 id="1-2-JAVA白皮书的关键术语"><a href="#1-2-JAVA白皮书的关键术语" class="headerlink" title="1.2 JAVA白皮书的关键术语"></a>1.2 JAVA白皮书的关键术语</h2><p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/language-environment.html">白皮书</a>以及<a target="_blank" rel="noopener" href="https://horstmann.com/corejava/java-an-overview/7Gosling.pdf">11个关键术语的概述</a></p>
<h3 id="1-2-1-简单性"><a href="#1-2-1-简单性" class="headerlink" title="1.2.1 简单性"></a>1.2.1 简单性</h3><p>JAVA语法是C++语法的一个纯净版本，没有头文件、指针运算（甚至没有指针语法）、结构、联合、操作符重载、虚基类等，但设计者并没有试图修正C++的所有不适当的特性。</p>
<h3 id="1-2-2-面向对象"><a href="#1-2-2-面向对象" class="headerlink" title="1.2.2 面向对象"></a>1.2.2 面向对象</h3><p>面向对象设计是一种程序设计技术，它将重点放在数据（即对象）和对象的接口上。Java与C++的不同点主要在于多重继承，在Java中取而代之的是更简单的接口概念。与C++相比，Java提供了更丰富的运行时自省功能。</p>
<h3 id="1-2-3-分布式"><a href="#1-2-3-分布式" class="headerlink" title="1.2.3 分布式"></a>1.2.3 分布式</h3><p>Java应用程序能够通过URL打开和访问网上的对象，其便捷程度就好像访问本地的文件一样（以前的特性，如今已理所当然）。</p>
<h3 id="1-2-4-健壮性"><a href="#1-2-4-健壮性" class="headerlink" title="1.2.4 健壮性"></a>1.2.4 健壮性</h3><p>Java编译器能够检测许多其他语言在运行时才能检测出来的问题。</p>
<h3 id="1-2-5-安全性"><a href="#1-2-5-安全性" class="headerlink" title="1.2.5 安全性"></a>1.2.5 安全性</h3><p>使用Java可以构建防病毒、防篡改的系统。</p>
<p>从一开始，Java就设计成能够防范各种攻击，其中包括：</p>
<ul>
<li><p>运行时堆栈溢出，这是蠕虫和病毒常用的攻击手段</p>
</li>
<li><p>破坏自己的进程空间之外的内存</p>
</li>
<li><p>未经授权读写文件</p>
<p>ActiveX：使用数字签名进行代码交付</p>
</li>
</ul>
<h3 id="1-2-6-体系结构中立"><a href="#1-2-6-体系结构中立" class="headerlink" title="1.2.6 体系结构中立"></a>1.2.6 体系结构中立</h3><p>编译器生成体系结构中立的目标文件格式，这是一种编译型代码，即Java通过生成与特定计算机体系结构无关的字节码指令来实现这一特性。</p>
<p>Java虚拟机还有一些其他优点，如它可以检查指令序列的行为，从而增强安全性。</p>
<h3 id="1-2-7-可移植性"><a href="#1-2-7-可移植性" class="headerlink" title="1.2.7 可移植性"></a>1.2.7 可移植性</h3><p>数值类型有固定的字节数，二进制数据以固定的格式进行存储和传输，消除了有关字节顺序的困扰，字符串则采用标准的Unicode格式存储。可以很好地支持平台独立性。（C&#x2F;C++中int可以是16&#x2F;32位整数&#x2F;编译器开发商指定的其他大小，在Java中总是32位）</p>
<h3 id="1-2-8-解释性"><a href="#1-2-8-解释性" class="headerlink" title="1.2.8 解释性"></a>1.2.8 解释性</h3><p>Java解释器可以在任何移植了解释器的机器码上直接执行Java字节码。</p>
<h3 id="1-2-9-高性能"><a href="#1-2-9-高性能" class="headerlink" title="1.2.9 高性能"></a>1.2.9 高性能</h3><p>即时编译器可以监控哪些代码频繁执行，并优化这些代码以提高速度。跟为复杂的优化是消除函数调用（内联）。</p>
<h3 id="1-2-10-多线程"><a href="#1-2-10-多线程" class="headerlink" title="1.2.10 多线程"></a>1.2.10 多线程</h3><p>第一个支持并发程序设计。</p>
<h3 id="1-2-11-动态性"><a href="#1-2-11-动态性" class="headerlink" title="1.2.11 动态性"></a>1.2.11 动态性</h3><p>库可以自由地添加新方法和实例变量，而对客户端没有任何影响。让一个正在运行的程序实现演进。</p>
<h2 id="1-3-JAVA-applet-与-Internet"><a href="#1-3-JAVA-applet-与-Internet" class="headerlink" title="1.3 JAVA applet 与 Internet"></a>1.3 JAVA applet 与 Internet</h2><p>在网页中运行的JAVA程序称为applet</p>
<h2 id="1-4-JAVA发展简史"><a href="#1-4-JAVA发展简史" class="headerlink" title="1.4 JAVA发展简史"></a>1.4 JAVA发展简史</h2><img src="/.io//1.jpg" alt="1.jpg">
<img src="/.io//2.jpg" alt="2.jpg">


<h2 id="1-5关于JAVA的常见误解"><a href="#1-5关于JAVA的常见误解" class="headerlink" title="1.5关于JAVA的常见误解"></a>1.5关于JAVA的常见误解</h2><ol>
<li><p>JAVA是HTML的扩展</p>
<p>JAVA是一种程序设计语言，而HTML是一种描述网页结构的方式。</p>
</li>
<li><p>我使用XML，不需要JAVA</p>
<p>XML是一种描述数据的方式，可以使用任意的程序设计语言处理XML数据，JAVA API对XML处理提供了很好的支持。</p>
</li>
<li><p>JAVA非常容易学习</p>
<p>数千个类和接口，数万个函数</p>
</li>
<li><p>JAVA将适用于所有平台</p>
<p>有可能，但某些领域其他语言有更出色的表现。比如objective C和后来的Swift在iOS设备上就有着无可替代的地位，浏览器中的处理几乎由JavaScript掌控，Windows程序通常用C++或C#编写，JAVA在服务器编程和跨平台客户端应用领域则很有优势。</p>
</li>
<li><p>JAVA一般</p>
<p>JAVA的成功源于其类库能够让人们很轻松地完成原本有一定难度的工作&#x2F;JAVA减少了指针错误……</p>
</li>
<li><p>JAVA是专用的，应避免使用</p>
<p>已开源</p>
</li>
<li><p>JAVA是解释性的，所以执行速度太慢了</p>
<p>现在的JAVA虚拟机使用了即时编译器（JIT，just in time），因此用JAVA编写的代码运行速度与C++相差无几，有些情况甚至更快</p>
</li>
<li><p>所有JAVA程序都在网页中运行</p>
<p>大多数程序都在服务器上运行，为网页生成代码或者计算业务逻辑</p>
</li>
<li><p>JAVA程序存在重大安全风险</p>
<p>虚拟机提供保护，JAVA应用比C或C++编写的应用要安全的多</p>
<p><img src="/.io//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250625012722518.png" alt="image-20250625012722518"></p>
</li>
<li><p>JavaScript是Java的简易版</p>
<p>JavaScript是一种可以在网页中使用的脚本语言，Java是强类型的，能够捕获类型滥用导致的很多错误，而JavaScript只有当程序运行时才能发现这些错误。</p>
</li>
<li><p>使用JAVA时可以用廉价的Internet设备代替桌面计算机</p>
</li>
</ol>
<p>​	网络计算机（是一种以网络为中心的计算设备，强调通过网络访问应用和数据，而不是依赖本地资源。它的理念在现代云计算、虚拟	化和瘦客户端技术中得到了延续。虽然在 20 世纪末未能大规模普及，但它为后来的网络化、云化计算奠定了基础）没有本地存储且	功能有限</p>
<h1 id="第二章-JAVA编程环境"><a href="#第二章-JAVA编程环境" class="headerlink" title="第二章 JAVA编程环境"></a>第二章 JAVA编程环境</h1><h2 id="2-1-安装Java开发工具包（JDK）"><a href="#2-1-安装Java开发工具包（JDK）" class="headerlink" title="2.1 安装Java开发工具包（JDK）"></a>2.1 安装Java开发工具包（JDK）</h2><h3 id="2-1-1-下载JDK"><a href="#2-1-1-下载JDK" class="headerlink" title="2.1.1 下载JDK"></a>2.1.1 下载JDK</h3><p><a target="_blank" rel="noopener" href="https://www.oracle.com/java/technologies/downloads/?er=221886">Java Downloads | Oracle</a></p>
<p><img src="/.io//06/24/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E7%AB%A0/1/3.jpg" alt="图片"></p>
<h3 id="2-1-2-设置JDK"><a href="#2-1-2-设置JDK" class="headerlink" title="2.1.2 设置JDK"></a>2.1.2 设置JDK</h3><p>重点：</p>
<ul>
<li><p>最好不要接受默认位置，自己选择路径，推荐安装在其他盘（如D&#x2F;E盘）</p>
</li>
<li><p>如何检测安装是否成功？</p>
<pre><code class="language-shell">javac -version
</code></pre>
</li>
</ul>
<p>​	出现版本信息则成功，如果报错则需仔细检查安装</p>
<ul>
<li><p>将JDK 的bin目录添加到可执行路径中——可执行路径是操作系统查找可执行文件时所遍历的目录列表</p>
<p>Linux系统：在<del>&#x2F;.bashrc或</del>&#x2F;.bash_profile文件的最后一行添加：</p>
<pre><code class="language-shell">export PATH=jdk/bin:$PATH
</code></pre>
<p>windows系统：在设置中搜索环境变量，编辑环境变量&#x2F;点击Win+R，输入sysdm.cpl，然后选择高级，再单击环境变量，在用户变量列表中找到并选择一个名为Path的变量，单击Edit再单击New，添加一个新值——jdk的bin目录</p>
</li>
</ul>
<h3 id="2-1-3-安装源文件和文档"><a href="#2-1-3-安装源文件和文档" class="headerlink" title="2.1.3 安装源文件和文档"></a>2.1.3 安装源文件和文档</h3><p>解压lib&#x2F;src.zip到新建的目录javasrc中，可通过终端创建该目录</p>
<pre><code class="language-shell">mkdir javasrc
cd javasrc
jar xvf jdk/lib/src.zip
cd ..
</code></pre>
<p>文档则包含在独立于JDK的一个压缩文件中，后续略</p>
<h2 id="2-2使用命令行工具"><a href="#2-2使用命令行工具" class="headerlink" title="2.2使用命令行工具"></a>2.2使用命令行工具</h2><pre><code>cd dir(该文件所在目录)
javac xxx.java
java xxx
</code></pre>
<p>此过程中javac编译器将xxx.java编译成xxx.class,java程序启动jvm,jvm执行编译器编译到类文件中的字节码</p>
<p><img src="/.io//06/24/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E7%AB%A0/1/4.jpg" alt="4.jpg"></p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/tutorial/getStarted/cupojava/netbeans.html">初学者易犯错误)</a></p>
<h2 id="2-3-使用集成开发环境"><a href="#2-3-使用集成开发环境" class="headerlink" title="2.3 使用集成开发环境"></a>2.3 使用集成开发环境</h2><p>下载JetBrains Toolbox，验证学生身份后即可免费使用，然后在工具箱中下载IntelliJ IDEA </p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_63173180/article/details/135510713">jetbrains工具箱教程：下载IDEA社区版与完全版的步骤-CSDN博客</a></p>
<h2 id="2-4-JShell"><a href="#2-4-JShell" class="headerlink" title="2.4 JShell"></a>2.4 JShell</h2><p>键入一个JAVA表达式，JShell会评估输入，打印结果并等待下一个输入</p>
<p><img src="/.io//5" alt="image-20250625020534877"></p>
<p>另一个有用的特性是“tab补全”，如果键入Math.然后按一次tab键，会得到Math类调用的所有方法的一个列表</p>
<p><img src="/.io//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250625020713157.png" alt="image-20250625020713157"></p>
<p>键入l,再按一次tab键，方法名会补全为log，然后得到一个比较小的列表</p>
<p><img src="/.io//Users\Lenovo\AppData\Roaming\Typora\typora-user-images\image-20250625020835072.png" alt="image-20250625020835072"></p>
<p><em><strong>小技巧</strong></em>：重复运行某个命令可按↑知道看到想要重复运行或编辑的命令行，←→移动光标至指定位置增加或删除指定字符</p>
<h1 id="第三章-JAVA的基本程序设计结构"><a href="#第三章-JAVA的基本程序设计结构" class="headerlink" title="第三章 JAVA的基本程序设计结构"></a>第三章 JAVA的基本程序设计结构</h1><h2 id="3-1-一个简单的JAVA程序"><a href="#3-1-一个简单的JAVA程序" class="headerlink" title="3.1 一个简单的JAVA程序"></a>3.1 一个简单的JAVA程序</h2><pre><code class="language-java">public class FirstSample &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;We will not use &#39;hello world!&#39;&quot;);
    &#125;
&#125;
</code></pre>
<ol>
<li><p>JAVA区分大小写</p>
</li>
<li><p>关键字public被称为访问修饰符，用于控制程序的其他部分对这段代码的访问级别</p>
</li>
<li><p>关键字class表明JAVA程序中的全部内容都包含在类中，类可以看做是<em><strong>程序逻辑的一个容器</strong></em>，定义了应用程序的行为；<em><strong>类是所有JAVA应用的构建模块</strong></em>，JAVA程序中的所有内容都必须放在类中</p>
</li>
<li><p>类名必须以字母开头，后面可以跟字母和数字的任意组合，长度没有限制，但是不能使用JAVA关键字（或被称为保留字）。标准命名约定为：类名是以<em><strong>大写字母开头的名词</strong></em>，如果名字由多个单词组成，那么每个单词的第一个字母都应该大写（驼峰&#x2F;骆驼命名法）</p>
</li>
<li><p>源代码的文件名必须和类名一致，并以.java作为扩展名，正确编译这个源代码之后，会得到一个包含这个类字节码的文件，JAVA编译器将这个字节码文件自动命名为FirstSample.class,并存储在源文件所在的同一个目录下，随便便可运行程序</p>
<pre><code>java FirstSample
</code></pre>
</li>
<li><p>运行一个已编译的程序时，Java虚拟机总是从指定类中main方法（即函数）的代码开始执行，因此类的源代码必须包含一个main方法</p>
</li>
<li><p><em><strong>main方法必须声明为public</strong></em>，详情可见<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/">Java语言规范</a></p>
</li>
<li><p>大括号用来划分程序的各个部分（通常称为块），任何方法的代码都必须以“{”开始，“}”结束；大括号的使用风格因人而异，JAVA编译器会忽略空白符，所以你可以选用自己喜欢的任何大括号风格</p>
<pre><code class="language-java">public class FirstSample &#123;
    public static void main(String[] args) &#123;
        System.out.println(&quot;We will not use &#39;hello world!&#39;&quot;);
    &#125;
&#125;
</code></pre>
<pre><code class="language-java">public class FirstSample 
&#123;
    public static void main(String[] args) 
    &#123;
        System.out.println(&quot;We will not use &#39;hello world!&#39;&quot;);
    &#125;
&#125;
教材推荐风格（把匹配的大括号对齐）
</code></pre>
</li>
<li><p>JAVA中的所有函数都是某个类的<em><strong>方法</strong></em>，因此，JAVA中的main方法必须有一个外壳（shell）类</p>
</li>
<li><p>与C&#x2F;C++相同，关键字void表示这个方法不返回值，但不同的是main方法不会为操作系统返回一个“退出码”。如果main方法正常退出，那么JAVA程序的退出码为0，表示成功地运行了程序，如果要以其他退出码终止程序，则需要使用System.exit方法</p>
</li>
<li><p>每个语句必须用分号结束，回车不是语句结束的标志，如果需要一条语句可以跨多行</p>
</li>
<li><p>.用于调用方法，JAVA使用的通用语法是object.method(parameters),这等价于一个函数调用，JAVA中的方法可以没有参数，也可以有一个或多个参数，即使没有参数，也需要使用空括号</p>
</li>
<li><p>println(a)&#x3D;print(a)+print(‘\n’)</p>
</li>
</ol>
<h2 id="3-2-注释"><a href="#3-2-注释" class="headerlink" title="3.2 注释"></a>3.2 注释</h2><p>JAVA中的注释不会出现在可执行程序中。所以可以添加任意多的注释而无须担心代码膨胀</p>
<p>共有三种注释方法</p>
<ol>
<li><p>从&#x2F;&#x2F;开始到本行结束都是注释</p>
<pre><code>//这是注释
</code></pre>
</li>
<li><p>可以使用 &#x2F;* 和 *&#x2F; 注释界定符将一段比较长的注释括起来</p>
<pre><code>/*
这是注释
这是注释
 */
</code></pre>
<p>&#x2F;* *&#x2F;   <em><strong>不能嵌套</strong></em></p>
</li>
<li><p>以 &#x2F;** 开始，以 *&#x2F; 结束的注释可以用来自动生成文档</p>
</li>
</ol>
<pre><code>/**
 * 这是注释
 * @version 111666
 * 888
 */
</code></pre>
<h2 id="3-3-数据类型"><a href="#3-3-数据类型" class="headerlink" title="3.3 数据类型"></a>3.3 数据类型</h2><p>JAVA是一种强类型语言，必须为每一个变量声明一个类型。在Java中，一共有8种基本类型，其中4种整型、2种浮点类型，1种字符类型，1种用于表示真值的boolean类型</p>
<blockquote>
<p>[!NOTE]</p>
<p>JAVA有一个能够表示任意精度的算数包，所谓的“大数”（big number）是JAVA对象而非基本类型。</p>
</blockquote>
<h3 id="3-3-1-整型"><a href="#3-3-1-整型" class="headerlink" title="3.3.1 整型"></a>3.3.1 整型</h3><p>整型用于表示没有小数部分的数，可以是负数。</p>
<table>
<thead>
<tr>
<th align="center">类型</th>
<th align="center">存储需求 字节数</th>
<th align="center">取值范围</th>
</tr>
</thead>
<tbody><tr>
<td align="center">int</td>
<td align="center">4</td>
<td align="center">-21 4748 3648~21 4748 3647(略高于20亿)</td>
</tr>
<tr>
<td align="center">short</td>
<td align="center">2</td>
<td align="center">-3 2768~3 2767</td>
</tr>
<tr>
<td align="center">long</td>
<td align="center">8</td>
<td align="center">-922 3372 0368 5477 5808~922 3382 0368 5477 5807</td>
</tr>
<tr>
<td align="center">byte</td>
<td align="center">1</td>
<td align="center">-128~127</td>
</tr>
</tbody></table>
<p>在Java中，<em><strong>整型的范围和运行Java代码的机器无关</strong></em>（保证在所有机器上都能得到相同的运行结果），与此相反，C&#x2F;C++会针对不同的处理器选择最高效的整型。<em><strong>JAVA没有无符号形式的int,long,byte,short类型</strong></em></p>
<blockquote>
<p>[!CAUTION]</p>
<p>如果使用不可能为负的整数值而且确实需要额外的一位（bit），也可以把有符号整数值解释为无符号数。例如，一个byte值b可以不表示-128~127的范围,如果你想表示0-255的范围，也可以存储在一个byte中。基于二进制算术运算的性质，只要不溢出，加法、减法、乘法都能正常运算。但对于其他运算，需要调用Byte.tuUnsignedInt(b)来得到一个0-255的int值，然后处理这个整数值，再把它转换回Byte.Integer和Long类都提供了处理无符号除法和余数的方法。</p>
</blockquote>
<p>长整型的后缀有一个L或1（如40 0000 0000L),十六进制数有一个前缀0x或0X（如0xCAFE),八进制有一个前缀0（010对应十进制里面的8），八进制易混淆，所以不建议使用，二进制数有一个前缀0b或0B。另外可以为数字字面量增加下划线，如1_000_000(或0b1111_0110_1101_0011)表示一百万，下划线的作用是为了增加易读性。</p>
<h3 id="3-3-2-浮点型"><a href="#3-3-2-浮点型" class="headerlink" title="3.3.2 浮点型"></a>3.3.2 浮点型</h3><p>浮点类型用来表示有小数部分的数。</p>
<table>
<thead>
<tr>
<th>类型</th>
<th>存储需求（字节数）</th>
<th>取值范围</th>
</tr>
</thead>
<tbody><tr>
<td>float</td>
<td>4</td>
<td>6-7位有效数字</td>
</tr>
<tr>
<td>double</td>
<td>8</td>
<td>15位有效数字</td>
</tr>
</tbody></table>
<p>$$<br>float取值范围大约为±3.40 282 347*10^{38}<br>$$</p>
<p>$$<br>double取值范围大约为±1.79 769 313 486 231 570*10^{308}<br>$$</p>
<p>double表示这种类型的数值精度是float的两倍，所以也被称为双精度数，很多时候float的精度并不能满足要求，所以除非必须使用单精度数否则基本上都使用double。float类型的数有一个后缀F或f（如3.14F），没有后缀的浮点数值总是默认为double类型。可选地，也可以在double类型的数后加上后缀D或d（如3.14D）。</p>
<blockquote>
<p>[!CAUTION]</p>
<p>可以使用十六进制表示浮点数字面量，例如0.123&#x3D;2^{-3}次方可以写成0x1.0p-3,在十六进制表示法中，使用p表示指数而不是e，因为e是十六进制数位。其中尾数采用十六进制，指数采用十进制。指数的基数是2，而不是10.</p>
</blockquote>
<p>所有浮点数计算都遵循IEEE754规范，具体来说，有三个特殊的浮点数值表示溢出和出错情况：</p>
<ul>
<li><p>正无穷大</p>
</li>
<li><p>负无穷大</p>
</li>
<li><p>NaN（不是一个数）</p>
<blockquote>
<p>[!CAUTION]</p>
<p>常量Double.POSITIVE_INFINITY和Double.NEGATIVE_INFINITY和Double.NaN（以及相应的float类型常量）分别表示这三个特殊的值。其中所有NaN的值都认为是不相同的故x&#x3D;&#x3D;Double.NaN is never true,只能通过Double.isNaN(x)来检测是否是Double.NaN</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>[!WARNING]</p>
<p>浮点数值不适用于无法接受舍入误差的金融计算，例如System.out.println(2.0-1.1)将打印出0.89999999999，而非我们期望中的0.9。这样的舍入误差主要原因是浮点数采用二进制表示，所以无法精确地表示1&#x2F;10，好比十进制无法精确地表示1&#x2F;3。如果需要精确的数值计算，不允许舍入误差，则应该使用BigDecimal类。</p>
</blockquote>
<h3 id="3-3-3-char型"><a href="#3-3-3-char型" class="headerlink" title="3.3.3 char型"></a>3.3.3 char型</h3><p>char类型的字面量值要用单引号括起来，例如，’A’是编码值为65的字符常量。它与”A”（包含一个字符的字符串）不同。char类型的值可以表示为十六进制值，其范围从\u0000-\uFFFF,例如，\u2122表示商标符号™ ，\u03C0表示希腊字母π。</p>
<p>除了转义序列\u以外，还有一些用来表示特殊字符的转义序列。</p>
<table>
<thead>
<tr>
<th>转义序列</th>
<th>名称</th>
<th>Unicode值</th>
</tr>
</thead>
<tbody><tr>
<td>\b</td>
<td>退格</td>
<td>\u0008</td>
</tr>
<tr>
<td>\t</td>
<td>制表</td>
<td>\u0009</td>
</tr>
<tr>
<td>\n</td>
<td>换行</td>
<td>\u000a</td>
</tr>
<tr>
<td>\r</td>
<td>回车</td>
<td>\u000d</td>
</tr>
<tr>
<td>\f</td>
<td>换页</td>
<td>\u000c</td>
</tr>
<tr>
<td>\ “(中间没有空格，添加空格防止在此处被转义)</td>
<td>双引号</td>
<td>\u0022</td>
</tr>
<tr>
<td>\ ‘(中间没有空格，添加空格防止在此处被转义)</td>
<td>单引号</td>
<td>\u0027</td>
</tr>
<tr>
<td>\ \ (中间没有空格，添加空格防止在此处被转义)</td>
<td>反斜线</td>
<td>\u005c</td>
</tr>
<tr>
<td>\s</td>
<td>空格，在文本块中用来保留末尾空白符</td>
<td>\u0020</td>
</tr>
<tr>
<td>\newline</td>
<td>只在文本块中使用，用来连接这一行和下一行</td>
<td>——</td>
</tr>
</tbody></table>
<p>可以在加引号的字符字面量或字符串中使用这些转义序列，例如’\u2122’或”Hello\n”。转义序列\u还可以在加引号字符常量或字符串之外使用（而其他所有转义序列不可以），如public static void main(String\u005B\u005D args)(但我自己在IDE上使用JAVA8编译报错，故此处存疑)，其中\u005B和\u005D是 [ 和 ] 的编码</p>
<blockquote>
<p>[!WARNING]</p>
<p>Unicode转义序列会在解析代码前处理。例如“\u0022+\u0022”会得到一个空串（解析为””+””）。更隐秘地，一定要注意注释中的\u，例如&#x2F;&#x2F; \u000A is a newline（\u000A会替换为一个换行符）会产生语法错误，&#x2F;&#x2F; look inside c:\users（\u后面没有跟着四位十六进制数）也会产生一个语法错误。</p>
</blockquote>
<h3 id="3-3-4-Unicode和char型"><a href="#3-3-4-Unicode和char型" class="headerlink" title="3.3.4 Unicode和char型"></a>3.3.4 Unicode和char型</h3><p>不同的编码机制标准：美国的ASCII，西欧语言的ISO 8859-1，俄罗斯的KOI-8，中国的GB 18030和BIG-5等</p>
<p><em><strong>码点（code point）是指与一个编码表中的某个字对应的代码值</strong></em>。在Unicode标准中，码点采用十六进制书写，并加上前缀U+，例如U+0041为拉丁字母A的码点。Unicode的码点可以氛围17个代码平面（code plane）。第一个代码平面称为基本多语言平面，范围为U+0000-U+FFFF，其余十六个平面从U+10000到U+10FFFF，包含各种辅助字符</p>
<p>UTF-16编码采用不同长度的代码来表示所有Unicode码点，在基本多语言平面中，每个字符用16位表示，通常称为<em><strong>代码单元</strong></em>；而辅助字符编码为一对连续的代码单元，采用这种编码对表示的每个值都属于基本多语言平面中未用的2048个值范围，通常称为替代区域（U+D800-U+DBFF用于第一个代码单元，U+DC00-U+DFFF用于第二个代码单元）。</p>
<blockquote>
<p>[!TIP]</p>
<p><em><strong>强烈建议不要使用char类型</strong></em>，除非确实需要处理UTF-16代码单元，最好将字符串作为抽象数据类型来处理</p>
</blockquote>
<h3 id="3-3-5-boolean类型"><a href="#3-3-5-boolean类型" class="headerlink" title="3.3.5 boolean类型"></a>3.3.5 boolean类型</h3><p>boolean类型有两个值：true和false，用来判定逻辑条件，<em><strong>整型值和布尔值之间不能互相转换</strong></em>。（在C++中，数值甚至指针可以代替布尔值，if(x&#x3D;0)在C++中始终为false,而在Java中无法通过编译，因为整数表达式x&#x3D;0不能转换为布尔值）</p>
<h2 id="3-4变量与常量"><a href="#3-4变量与常量" class="headerlink" title="3.4变量与常量"></a>3.4变量与常量</h2><p>常量就是值不变的变量。</p>
<h3 id="3-4-1声明变量"><a href="#3-4-1声明变量" class="headerlink" title="3.4.1声明变量"></a>3.4.1声明变量</h3><p>声明是一个完整的JAVA语句，先指定变量类型，然后是变量名，每个声明都以分号结束</p>
<pre><code class="language-java">double salary;
</code></pre>
<p>作为变量名的标识符<em><strong>由字母、数字、货币符号以及”标点连接符”组成</strong></em>，<em><strong>第一个字符不能是数字</strong></em>，’+’、空格等不能出现，字母<em><strong>区分大小写</strong></em>，<em><strong>不能使用Java关键字</strong></em>作为变量名，可以一行声明多个变量，但推荐<em><strong>分别声明</strong></em>以此来提高程序可读性</p>
<blockquote>
<p>[!NOTE]</p>
<p>如果想要知道标识符中可以使用哪些Unicode字符，可以使用Charater类的<em><strong>isJavaIdentifierStart</strong></em>和<em><strong>isJavaIdentifierPart</strong></em>来检查</p>
</blockquote>
<h3 id="3-4-2初始化变量"><a href="#3-4-2初始化变量" class="headerlink" title="3.4.2初始化变量"></a>3.4.2初始化变量</h3><p>声明变量后必须显式地使用赋值语句初始化变量，不能使用未初始化的变量。</p>
<pre><code class="language-java">double salary;
salary=10000;
</code></pre>
<pre><code class="language-java">double salary=10000;
</code></pre>
<blockquote>
<p>[!TIP]</p>
<p>变量的声明应尽可能靠近第一次使用这个变量的地方</p>
</blockquote>
<p>从Java10开始，如果可以从变量的初始值推断出其类型，则无需声明类型，只需要使用关键字var</p>
<pre><code class="language-java">var salary=10000;
var greeting=&quot;hello&quot;;
</code></pre>
<h4 id="声明与定义"><a href="#声明与定义" class="headerlink" title="声明与定义"></a>声明与定义</h4><p>声明：不分配内存（变量）&#x2F;不提供具体实现（方法函数）</p>
<p>定义则反之</p>
<h3 id="3-4-3常量"><a href="#3-4-3常量" class="headerlink" title="3.4.3常量"></a>3.4.3常量</h3><p>可以使用<em><strong>final</strong></em>关键字来指示，表示该变量<em><strong>只能被赋值一次</strong></em>，一旦赋值就无法更改，习惯上，<em><strong>常量名使用全大写</strong></em></p>
<pre><code class="language-java">final double pai=3.14;
</code></pre>
<p>类常量（class constant）：在一个类的多个方法中使用，使用static final设置 ,定义位于main函数之外，如果一个类常量声明为public，那么其他类也可以使用这个常量，通过<em><strong>类名.类常量名</strong></em>的形式调用</p>
<pre><code class="language-java">public static final double pai=3.14;
</code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>const是Java保留的关键字，目前并没有使用，在Java中必须使用final声明常量</p>
</blockquote>
<h3 id="3-4-4枚举类型"><a href="#3-4-4枚举类型" class="headerlink" title="3.4.4枚举类型"></a>3.4.4枚举类型</h3><p>一个变量<em><strong>只包含有限的一组值</strong></em>。例如</p>
<pre><code class="language-java">enum Size&#123;SMALL,MEDIUM,LARGE,EXTRA_LARGE&#125;;
Size s=Size.MEDIUM;
</code></pre>
<p>Size类型的变量<em><strong>只能存储这个类型声明中所列的某个值，或者特殊值null</strong></em>，null表示这个变量没有设置任何值</p>
<h2 id="3-5运算符"><a href="#3-5运算符" class="headerlink" title="3.5运算符"></a>3.5运算符</h2><p>运算符用于连接值。</p>
<h3 id="3-5-1算术运算符"><a href="#3-5-1算术运算符" class="headerlink" title="3.5.1算术运算符"></a>3.5.1算术运算符</h3><p>+，-，*，&#x2F; 加减乘除 求余%</p>
<p>当参与&#x2F;运算的两个操作数都为整数时，&#x2F;表示整数除法，否则这表示浮点数除法 15&#x2F;2&#x3D;7 15.0&#x2F;2&#x3D;7.5</p>
<p><em><strong>整数被零除将产生一个异常，而浮点数被零除将会得到一个无穷大或NaN结果</strong></em> x&#x2F;0</p>
<h3 id="3-5-2-数学函数与常量"><a href="#3-5-2-数学函数与常量" class="headerlink" title="3.5.2 数学函数与常量"></a>3.5.2 数学函数与常量</h3><p>Math类中包含了各种常用的数学函数</p>
<p>要想计算一个数的平方根，可以使用sqrt函数</p>
<pre><code class="language-java">double x=4;
double y=Math.sqrt(x);
System.out.println(y);//prints 2.0
</code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>println方法处理System.out对象，而Math类中的sqrt方法并不处理任何对象，这样的方法被称为静态方法（static method）</p>
</blockquote>
<p>在Java中，没有完成幂运算的运算符，故必须使用Math类中的pow方法，<em><strong>pow方法有两个double类型的参数，其返回类型也为double</strong></em></p>
<pre><code class="language-java">double y=Math.pow(x,a);//将y设置为x的a次幂
</code></pre>
<p>floorMod方法是为了解决整数余数问题（n%2当n为负奇数时结果为-1）</p>
<p><em><strong>最优规则（欧几里得规则）：余数总是大于等于0</strong></em></p>
<p>计算一个时钟时针的位置，这里要做一个调整，归一化为一个0-11之间的数，若使用式（position+adjustment）%12,当调整为负数时可能会得到一个负数，若使用（（position+adjustment）%12+12）%12则很麻烦，使用floorMod(position+adjustment，12)总会得到一个0-11之间的数（但对于负除数floorMod会得到负数结果）</p>
<p>常用三角函数</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>Math.sin</td>
<td>求正弦</td>
</tr>
<tr>
<td>Math.cos</td>
<td>求余弦</td>
</tr>
<tr>
<td>Math.tan</td>
<td>求正切</td>
</tr>
<tr>
<td>Math.atan</td>
<td>求反正切值</td>
</tr>
<tr>
<td>Math.atan2</td>
<td>求y&#x2F;x的反正切值</td>
</tr>
</tbody></table>
<p>指数函数及对数函数（指数函数的反函数）</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>Math.exp</td>
<td>指数函数</td>
</tr>
<tr>
<td>Math.log</td>
<td>求解自然对数</td>
</tr>
<tr>
<td>Math.log10</td>
<td>求解以10为底的对数</td>
</tr>
</tbody></table>
<p>以上方法参数及返回值均为double类型，且均为静态方法，可直接通过Math类调用，<em><strong>无需创建Math对象</strong></em></p>
<p>常用常量</p>
<table>
<thead>
<tr>
<th>函数名称</th>
<th>用处</th>
</tr>
</thead>
<tbody><tr>
<td>Math.PI</td>
<td>π</td>
</tr>
<tr>
<td>Math.E</td>
<td>e</td>
</tr>
</tbody></table>
<blockquote>
<p>[!TIP]</p>
<p>可以使用静态导入，这样就不用在方法名和常量名前添加前缀Math</p>
<pre><code class="language-java">import static java lang.Math.*
</code></pre>
<pre><code class="language-java">System.out.println(sqrt(PI));
</code></pre>
</blockquote>
<p>如果得到一个完全可预测的结果比运行速度更重要的话，应该使用<em><strong>StrictMath类</strong></em>，确保在所有平台上得到相同的结果</p>
<blockquote>
<p>[!CAUTION]</p>
<p>Math类提供了一些方法让整数运算更加安全，如果一个计算溢出，数学运算只是<em><strong>悄悄地返回错误的结果而不做任何提醒</strong></em>，使用Math.multiplyExact（10 0000 0000，3）就会生成一个异常，使得你可以<em><strong>捕获这个异常并进行处理</strong></em>，还存在其他方法（abbExact,subtractExact,incrementExact,decrementExact,negateExact,absExact）也可以正确地处理int和long参数</p>
</blockquote>
<h3 id="3-5-3数值类型之间的转换"><a href="#3-5-3数值类型之间的转换" class="headerlink" title="3.5.3数值类型之间的转换"></a>3.5.3数值类型之间的转换</h3><p><img src="/.io//06/24/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E7%AB%A0/1/6.jpg" alt="6"></p>
<p>其中实线类型表示无信息丢失的转换，而另有三个虚线箭头，表示有精度损失的转换</p>
<pre><code class="language-java">int n=123456789;
float f=n;//f is 1.23456792E8
</code></pre>
<p>当用一个二元运算符连接两个值时，需要<em><strong>先将两个操作数转换为同一种类型</strong></em>，然后再进行计算</p>
<ul>
<li>如果有一个是double类型，那么另一个就会转换为double类型</li>
<li>否则，如果有一个是float类型，那么另一个就会转换为float类型</li>
<li>否则，如果有一个是long类型，那么另一个就会转换为long类型</li>
<li>否则，两个都被转换为int类型</li>
</ul>
<p>即优先转换为精度高的浮点数类型</p>
<h3 id="3-5-4强制类型转换"><a href="#3-5-4强制类型转换" class="headerlink" title="3.5.4强制类型转换"></a>3.5.4强制类型转换</h3><p>可能丢失信息的转换要通过强制类型转换来完成,确保开发者知道转换后果</p>
<p>强制类型转换（cast）的语法格式是在圆括号中指定想要转换的目标类型，后面紧跟待转换的变量名</p>
<pre><code class="language-java">double x=9.997;
int nx=(int)x;//nx is 9
</code></pre>
<p>强制类型转换通过<em><strong>截断小数部分将浮点值转换为整型</strong></em></p>
<p>若想舍入（round）一个浮点数来得到一个最接近的整数，可以使用Math.round方法</p>
<pre><code class="language-java">double x=9.997;
int nx=(int)Math.round(x);//nx is 10
</code></pre>
<p>之所以还需要进行强制类型转换是因为round方法的返回值为long类型</p>
<blockquote>
<p>[!WARNING]</p>
<p>如果试图将一个数从一种类型强制转换为另一种类型而又超出了目标类型的表示范围，结果就会截断成一个完全不同的值，如（byte）300&#x3D;44</p>
</blockquote>
<p><em><strong>不要在boolean类型和任何类型之间进行强制类型转换</strong></em>，若需要将boolean类型转换成一个数，可以使用条件表达式b?1:0</p>
<h3 id="3-5-5赋值"><a href="#3-5-5赋值" class="headerlink" title="3.5.5赋值"></a>3.5.5赋值</h3><p>可以在赋值中使用二元运算符 +&#x3D; *&#x3D; %&#x3D; …</p>
<pre><code class="language-java">x+=4;//等价于x=x+4
</code></pre>
<blockquote>
<p>[!WARNING]</p>
<p>如果运算符得到一个值，其类型与左侧操作数的类型不同，就会发生强制类型转换</p>
<pre><code class="language-java">int x;
...
x+=3.5;//x被设置为（int）(x+3.5)
</code></pre>
</blockquote>
<p>在Java中，<em><strong>赋值是一个表达式，即表达式有一个值（所赋的值）</strong></em></p>
<pre><code class="language-java">int x=1;
int y= x+=4;//x+=4的值是5
</code></pre>
<p>但不推荐这样写，嵌套赋值容易混淆</p>
<h3 id="3-5-6自增与自减运算符"><a href="#3-5-6自增与自减运算符" class="headerlink" title="3.5.6自增与自减运算符"></a>3.5.6自增与自减运算符</h3><table>
<thead>
<tr>
<th>类型</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>n++</td>
<td>先使用n原来的值，然后n自增1</td>
</tr>
<tr>
<td>++n</td>
<td>n先自增1，然后使用n的值</td>
</tr>
<tr>
<td>n–</td>
<td>先使用n原来的值，然后n自减1</td>
</tr>
<tr>
<td>–n</td>
<td>n先自减1，然后使用n的值</td>
</tr>
</tbody></table>
<pre><code class="language-java">int m=7;
int n=7;
int a=2*(++m);//now a is 16,m is 8
int b=2*(n++);//now b is 14,n is 8
</code></pre>
<p>但在Java中较少使用</p>
<h3 id="3-5-7关系和boolean运算符"><a href="#3-5-7关系和boolean运算符" class="headerlink" title="3.5.7关系和boolean运算符"></a>3.5.7关系和boolean运算符</h3><p>&#x3D;&#x3D;，！&#x3D;，&lt;,&gt;,&lt;&#x3D;,&gt;&#x3D;关系运算符 3&#x3D;&#x3D;7值为false</p>
<p>&amp;&amp;逻辑与运算 ||逻辑或运算  ！逻辑非运算 &amp;&amp;与||是<em><strong>按照短路方式来求值</strong></em>的，即<em><strong>如果第一个操作数已经能够确定表达式的值，那么第二个操作数就不会计算</strong></em></p>
<p>如exp1&amp;&amp;exp2，若exp1真值为false，就不会计算exp2,可以利用这种行为来避免错误</p>
<p>如x!&#x3D;0&amp;&amp;1&#x2F;x&gt;x+y&#x2F;&#x2F;no division by 0 如果x&#x3D;0，那么第二部分就不会计算，exp1||exp2同理</p>
<h3 id="3-5-8-条件运算符"><a href="#3-5-8-条件运算符" class="headerlink" title="3.5.8 条件运算符"></a>3.5.8 条件运算符</h3><p>condition?exp1:exp2 如果condition为真，表达式计算为exp1的值，反之则为exp2的值</p>
<p>如x&lt;y?x:y 会返回x、y中较小的一个</p>
<h3 id="3-5-9-switch表达式"><a href="#3-5-9-switch表达式" class="headerlink" title="3.5.9 switch表达式"></a>3.5.9 switch表达式</h3><p>需要在两个以上的值中做出选择时，可以使用switch表达式（Java14后引入）</p>
<pre><code class="language-java">        String seasonName=switch(seasonCode)
        &#123;
            case 0-&gt; &quot;Spring&quot;;
            case 1-&gt; &quot;Summer&quot;;
            case 2-&gt; &quot;Autumn&quot;;
            case 3-&gt; &quot;Winter&quot;;
            default -&gt; &quot;Error&quot;;
        &#125;;
</code></pre>
<p>case标签还可以是字符串或者是枚举类型常量</p>
<p>与所有表达式一样，switch表达式也有一个值</p>
<p>可以为各个case提供多个标签</p>
<pre><code class="language-java">        int numLetters=switch (seasonName)
        &#123;
            case &quot;Spring&quot;,&quot;Summer&quot;,&quot;Winter&quot; -&gt; 1;
            case &quot;Fall&quot; -&gt; 2;
            default -&gt; -1;
        &#125;;
</code></pre>
<p>switch表达式中使用枚举常量时，不需要为各个标签提供枚举名</p>
<pre><code class="language-java">enum Size&#123;SMALL,MEDIUM,LARGE,EXTRA_LARGE&#125;;
...
Size itemSize=...;
String label=switch(itemSize)
&#123;
    case SMALL -&gt; &quot;S&quot;;//no need to use Size.SMALL
    case MEDIUM -&gt; &quot;M&quot;;
    case LARGE -&gt; &quot;L&quot;;
    case EXTRA_LARGE -&gt; &quot;XL&quot;;
&#125;;
</code></pre>
<p>在该例子中完全可以省略default，因为<em><strong>每一个可能的值都有相应的一个case</strong></em></p>
<blockquote>
<p>[!WARNING]</p>
<p>使用整数或者String操作数的switch表达式必须有一个default，因为不论操作数值是什么，这个表达式都必须生成一个值；如果操作数为null，那么会抛出一个NullPointerException</p>
</blockquote>
<h3 id="3-5-10-位运算符"><a href="#3-5-10-位运算符" class="headerlink" title="3.5.10 位运算符"></a>3.5.10 位运算符</h3><p><em><strong>处理整数类型时</strong></em>，有一些运算符可以直接处理组成整数的各个位，这意味着<em><strong>可以使用掩码技术得到一个数中的各个位</strong></em></p>
<p>位运算符包括：&amp;（and） |(or)   ^(xor)  -(not)</p>
<p>如果n是一个整数变量，而且n的二进制表示中从右边数第四位为1，则</p>
<pre><code class="language-java">int fourthBitFromRight=(n &amp; 0b1000)/0b1000;
</code></pre>
<p>会返回1，否则返回0。利用&amp;并结合适当的2的幂，可以屏蔽其他位，而只留下其中的某一位</p>
<blockquote>
<p>[!CAUTION]</p>
<p>应用在布尔值上时，&amp;和|也会得到一个布尔值，这些运算符和&amp;&amp;与||很像，不过&amp;和|不采用短路方式来求值，也就是说计算结果之前两个操作数都需要计算</p>
</blockquote>
<p>另外还有&lt;&lt;和&gt;&gt;运算符可以将位模式左移或右移。</p>
<pre><code class="language-java">int fourthBitFromRight=(n &amp;(1&lt;&lt;3))&gt;&gt;3； 
</code></pre>
<p><em><strong>运算符&gt;&gt;&gt;会用0填充高位，&gt;&gt;则会用符号位填充高位</strong></em>。不存在&lt;&lt;&lt;运算符</p>
<blockquote>
<p>[!WARNING]</p>
<p>移位运算符的右操作数要完成模32的运算，除非左操作数是long类型，此时模64，例如1&lt;&lt;35的值等同于1&lt;&lt;3g或8</p>
</blockquote>
<blockquote>
<p>[!NOTE]</p>
<p>C&#x2F;C++中，不能保证&gt;&gt;是完成算术移位（扩展符号位）还是逻辑移位（填充0），Java消除了这种不确定性</p>
</blockquote>
<h3 id="3-5-11括号与运算符级别"><a href="#3-5-11括号与运算符级别" class="headerlink" title="3.5.11括号与运算符级别"></a>3.5.11括号与运算符级别</h3><p>同一级别的运算符按从左到右的运算次序进行计算（右结合运算符除外）</p>
<p>a &amp;&amp; b||c由于&amp;&amp;的优先级比||高，所以等价于(a&amp;&amp;b)||c</p>
<p>因为+&#x3D;是右结合运算符，所以a+&#x3D;b+&#x3D;c等价于a+&#x3D;(b+&#x3D;c)</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>结合性</th>
</tr>
</thead>
<tbody><tr>
<td>[].()(方法调用)</td>
<td>从左向右</td>
</tr>
<tr>
<td>!~++–+(一元运算)-(一元运算)（）（强制类型转换）new</td>
<td><em><strong>从右向左</strong></em></td>
</tr>
<tr>
<td>*&#x2F;%</td>
<td>从左向右</td>
</tr>
<tr>
<td>+-</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt;&lt; &gt;&gt; &gt;&gt;&gt;</td>
<td>从左向右</td>
</tr>
<tr>
<td>&lt; &lt;&#x3D; &gt; &gt;&#x3D;  instanceof</td>
<td>从左向右</td>
</tr>
<tr>
<td>&#x3D;&#x3D;  !&#x3D;</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>^</td>
<td>从左向右</td>
</tr>
<tr>
<td>|</td>
<td>从左向右</td>
</tr>
<tr>
<td>&amp;&amp;</td>
<td>从左向右</td>
</tr>
<tr>
<td>||</td>
<td>从左向右</td>
</tr>
<tr>
<td>?:</td>
<td><em><strong>从右向左</strong></em></td>
</tr>
<tr>
<td>&#x3D; +&#x3D; -&#x3D; *&#x3D; &#x2F;&#x3D; %&#x3D; &amp;&#x3D; |&#x3D; ^&#x3D; &lt;&lt;&#x3D; &gt;&gt;&#x3D; &gt;&gt;&gt;&#x3D;</td>
<td><em><strong>从右向左</strong></em></td>
</tr>
</tbody></table>
<h2 id="3-6字符串"><a href="#3-6字符串" class="headerlink" title="3.6字符串"></a>3.6字符串</h2><p><em><strong>Java字符串就是Unicode字符序列</strong></em>，<em><strong>Java没有内置的字符串类型，而是标准Java类库中提供了一个预定义类String</strong></em>，每个用双引号括起来的字符串都是String类的一个实例。</p>
<h3 id="3-6-1-子串"><a href="#3-6-1-子串" class="headerlink" title="3.6.1 子串"></a>3.6.1 子串</h3><pre><code class="language-java">String greeting=&quot;Hello&quot;;
String s=greeting.substring(0,3);//创建一个由字符”Hel&quot;组成的字符串
</code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>类似于C&#x2F;C++，Java字符串中的代码单元和码点从0开始计数</p>
</blockquote>
<p><em><strong>substring的第二个参数是你不想复制的第一个位置</strong></em>，[a,b)，这样也有一个优点：很容易计算子串长度——b-a</p>
<h3 id="3-6-2-拼接"><a href="#3-6-2-拼接" class="headerlink" title="3.6.2 拼接"></a>3.6.2 拼接</h3><p>Java<em><strong>允许使用+号拼接字符串</strong></em>，当将一个字符串与一个非字符串进行拼接时，后者会被转换成字符串（任何一个Java对象都可以转换成字符串）</p>
<pre><code class="language-java">int age=13;
String rating=&quot;PG&quot;+age;//rating is &quot;PG13&quot;
</code></pre>
<p>此特性常用于输出</p>
<pre><code class="language-java">System.out.println(&quot;The answer is &quot;+answer);
</code></pre>
<p>如果需要把多个字符串放在一起，用一个界定符分隔，可以使用<em><strong>静态join方法</strong></em></p>
<pre><code class="language-java">String all=String.join(&quot;/&quot;,&quot;S&quot;,&quot;M&quot;,&quot;L&quot;,&quot;XL&quot;);//all is the string &quot;S/M/L/XL&quot;
</code></pre>
<p>Java11中，还提供了<em><strong>repeat方法</strong></em></p>
<pre><code class="language-java">String repeated=&quot;java&quot;.repeat(3);//repeated is &quot;javajavajava&quot;
</code></pre>
<h3 id="3-6-3-字符串不可变"><a href="#3-6-3-字符串不可变" class="headerlink" title="3.6.3 字符串不可变"></a>3.6.3 字符串不可变</h3><p><em><strong>String类没有提供任何方法来修改字符串中的某个字符</strong></em>，可以提取想要保留的子串，再与希望替换的字符拼接</p>
<pre><code class="language-java">String greeting=&quot;Hello&quot;;
greeting=greeting.substring(0,3)+&quot;p!&quot;;//&quot;Help!&quot;
</code></pre>
<p>文档中将<em><strong>String类对象称为是不可变的</strong></em>，如同数字3永远是数字3，字符串”Hello”永远包含字符H、e、l、l、o的代码单元序列。如上修改的方式实质是指向了另一个字符串</p>
<p>不可变字符串有一个很大的优点：<em><strong>编译器可以让字符串共享</strong></em>。工作原理：可以想象各个字符串存放在一个公共存储池中，字符串变量指向存储池中的相应位置，如果复制一个字符串变量，原始字符串和复制的字符串共享相同的字符。故Java设计者认为共享带来的高效率远远超过编辑字符串（提取子串和拼接字符串）所带来的低效率。</p>
<blockquote>
<p>[!NOTE]</p>
<p>Java字符串与C++中的字符数组char a[]不同，但与char* a指针类似，即a指向某个字符串。C++中的字符串是可修改&#x2F;可变的</p>
</blockquote>
<h3 id="3-6-4-检测字符串是否相等"><a href="#3-6-4-检测字符串是否相等" class="headerlink" title="3.6.4 检测字符串是否相等"></a>3.6.4 检测字符串是否相等</h3><p>使用<em><strong>equals方法</strong></em>检测字符串是否相等</p>
<pre><code class="language-java">s.equals(t);//其中s、t可以是字符串变量（greeting）也可以是字符串字面量(&quot;Hello&quot;),若相等返回true，不等返回false
</code></pre>
<p>若要检测两个字符串是否相等而不区分大小写，可以使用<em><strong>equalsIgnoreCase方法</strong></em></p>
<pre><code class="language-java">&quot;Hello&quot;.equalsIgnoreCase(&quot;hello&quot;);//true
</code></pre>
<p><em><strong>不能使用&#x3D;&#x3D;运算符检测两个字符串是否相等</strong></em>，这样只能检测两个字符串是否放在同一个位置，但是完全可能将多个相等的字符串副本放在不同的地方</p>
<pre><code class="language-java">String greeting=&quot;Hello&quot;;
if(greeting==&quot;Hello&quot;)...//probably true
if(greeting.substring(0,3)==&quot;Hel&quot;)...//probably false
</code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>如果虚拟机总是共享相等的字符串，那么可以使用&#x3D;&#x3D;。但实际上只有字符串字面量会共享，而+或substring等操作得到的字符串并不共享，因此，<em><strong>千万不要使用&#x3D;&#x3D;测试字符串的相等性</strong></em></p>
</blockquote>
<blockquote>
<p>[!CAUTION]</p>
<p>C++的string类<em><strong>重载了&#x3D;&#x3D;运算符</strong></em>，从而能检测字符串内容的相等性。Java字符串的外观像数值，但是进行相等性测试时，则表现得类似于指针。C语言使用<em><strong>str函数</strong></em>进行比较，Java中也提供了类似的<em><strong>compareTo方法</strong></em></p>
<pre><code class="language-java">if(greeting.compareTo(&quot;Hello&quot;)==0)...
</code></pre>
<p>但还是推荐使用更为清晰的equals方法</p>
</blockquote>
<h3 id="3-6-5空串与Null串"><a href="#3-6-5空串与Null串" class="headerlink" title="3.6.5空串与Null串"></a>3.6.5空串与Null串</h3><p><em><strong>空串””是长度为0的字符串，是一个Java对象，有自己的长度（0）和内容（空）</strong></em></p>
<p>String变量还可以存在一个特殊的值，名为null，表示<em><strong>目前没有任何对象与该变量关联</strong></em></p>
<p>若要检查一个字符串既不是null也不是空串，可以使用</p>
<pre><code class="language-java">if(str!=null &amp;&amp; str.length()!=0)
</code></pre>
<p><em><strong>首先要检查str不为null</strong></em>，因为如果在一个null值上调用方法，会出现错误，所以上述检查顺序不可调换</p>
<h3 id="3-6-6-码点与代码单元"><a href="#3-6-6-码点与代码单元" class="headerlink" title="3.6.6 码点与代码单元"></a>3.6.6 码点与代码单元</h3><p>length()方法将返回采用UTF-16编码表示给定字符串所需要的代码单元个数。</p>
<pre><code class="language-java">String greeting=&quot;Hello&quot;;
int n=greeting.length();//n is 5
</code></pre>
<p>要想得到实际长度，即码点个数，调用：</p>
<pre><code class="language-java">int cpCount=greeting.codePointerCount(0,greeting.length());
</code></pre>
<p>调用s.charAt(n)将返回位置n的代码单元，<em><strong>n介于0~s.length()-1之间</strong></em></p>
<pre><code class="language-java">char first=greeting.charAt(0);//&quot;H&quot;
char last=greeting.charAt(4);//&quot;o&quot;
</code></pre>
<pre><code class="language-java">String sentence=&quot;😈 is a sentence&quot;;

int n=sentence.length();
int cpCount=sentence.codePointCount(0, sentence.length());

int index=sentence.offsetByCodePoints(0, 0);
int cp=sentence.codePointAt(index);//得到第0个码点

System.out.println(n);//16 😈占用两个代码单元
System.out.println(cpCount);//15
System.out.println(cp);//128520
</code></pre>
<p>不能忽略在U+FFFF以上的奇怪字符，喜欢emoji表情符号的用户可能会在字符串中下入类似🍺的字符</p>
<p>要想遍历一个字符串并且一次查看每一个码点，可以使用以下语句</p>
<pre><code class="language-java">int cp=sentence.codePointAt(i);
i+=Character.charCount(cp);
</code></pre>
<p>可以使用以下语句实现反向遍历</p>
<pre><code class="language-java">i--；
if(Character.isSurrogate(sentence.charAt(i))) i--;//判断是否是辅助字符/代理字符
int cp=sentence.codePointAt(i);
</code></pre>
<p>使用<em><strong>codePoints</strong></em>方法更为简易，它会生成int值的一个流，每个int值对应一个码点，可以将流转换为一个数组，再完成遍历</p>
<pre><code class="language-java">int[] codePoints=str.codePoints().toArray();
</code></pre>
<p>反之要把一个码点数组转换为字符串，可以使用构造器</p>
<pre><code class="language-java">String str=new String(codePoints,0,codePoints.length);
</code></pre>
<p>要把单个码点转换成字符串，可以使用***Character.toString(int)***方法</p>
<pre><code class="language-java">int codePoint=0x1F37A;
str=Character.toString(codePoint);
</code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>虚拟机不一定把字符串实现为代码单元序列，在Java9中使用了一个跟为紧凑的表示，如果只包含单字节代码单元，字符串使用Byte数组实现，所有其他字符串使用char数组</p>
</blockquote>
<h3 id="3-6-7-String-API"><a href="#3-6-7-String-API" class="headerlink" title="3.6.7 String API"></a>3.6.7 String API</h3><p><em><strong>API（Application Programming Interface）：应用程序编程接口</strong></em></p>
<p>类 java.lang.String <strong>1.0</strong>(引入版本号，下同)</p>
<ul>
<li><p>char charAt(int index)</p>
<p>返回给定位置的代码单元，除非对底层代码感兴趣，否则不需要</p>
</li>
<li><p>int codePointAt(int index)  <strong>5</strong></p>
<p>返回从给定位置开始的码点</p>
</li>
<li><p>int offsetByCodePoints(int startIndex,int cpCount)  <strong>5</strong></p>
<p>返回从startIndex码点开始，cpCount个码点后的码点索引</p>
</li>
<li><p>int compareTo(String other)</p>
<p>按照字典顺序，如果字符串位于other之前，返回一个负数；如果相等，返回0；如果位于之后，返回一个正数</p>
</li>
<li><p>IntStream codePoints()  <strong>8</strong></p>
<p>将这个字符串的码点作为一个流返回，调用toArray将它们放在数组中</p>
</li>
<li><p>new Stirng(int[] codePoints,int offset,int count)  <strong>5</strong></p>
<p>用数组中从offset开始的count个码点构造一个字符串</p>
</li>
<li><p>boolean isEmpty() </p>
<p>boolean isBlank()  <strong>11</strong></p>
<p>如果字符串为空&#x2F;由空白符组成，返回true</p>
</li>
<li><p>boolean equals(Object other)</p>
<p>如果字符串与other相等，返回true</p>
</li>
<li><p>boolean equalsIgnoreCase(String other)</p>
<p>如果字符串与other相等（忽略大小写），返回true</p>
</li>
<li><p>boolean startsWith(String prefix)</p>
<p>boolean endsWith(String suffix)</p>
<p>如果字符串以prefix开头或者以suffix结尾返回true</p>
</li>
<li><p>int indexOf(String str)</p>
</li>
<li><p>int indexOf(String str,int fromIndex)</p>
</li>
<li><p>int indexOf(int cp)</p>
</li>
<li><p>int indexOf(int cp,int fromIndex)</p>
<p>返回与字符串str或码点cp相等的第一个子串的开始位置，从索引0或fromIndex开始匹配，如果str或cp不在字符串中，则返回-1</p>
</li>
<li><p>int lastIndexOf(String str)</p>
</li>
<li><p>int lastIndexOf(String str,int fromIndex)</p>
</li>
<li><p>int lastIndexOf(int cp)</p>
</li>
<li><p>int lastIndexOf(int cp,int fromIndex)</p>
<p>返回与字符串str或码点cp相等的最后一个子串的开始位置，从字符串末尾或fromIndex开始匹配，如果str或cp不在字符串中，则返回-1</p>
</li>
<li><p>int length()</p>
<p>返回字符串代码单元的个数</p>
</li>
<li><p>int codePointCount(int startIndex,int endIndex)  <strong>5</strong></p>
<p>返回从startIndex到endIndex-1之间的码点个数</p>
</li>
<li><p>String replace(CharSequence oldString,CharSequence newString)</p>
<p>返回一个新字符串，这是用newString替换原始字符串中与oldString匹配的所有子串得到的，可以用String或者StringBuilder对象作为CharSequence参数</p>
</li>
<li><p>String substring(int beginIndex)</p>
</li>
<li><p>String substring(int beginIndex,int endIndex)</p>
<p>返回一个新字符串，这个字符串包含原始字符串从beginIndex开始到字符串末尾或endIndex-1的所有代码单元</p>
</li>
<li><p>String toLowerCase()</p>
</li>
<li><p>String toUpperCase()</p>
<p>返回一个新字符串，这个字符串包含原始字符串中的所有字符，不过将原始字符串中的大写字母全部小写，或将小写字母全部大写</p>
</li>
<li><p>String strip()  <strong>11</strong></p>
<p>String stripLeading()  <strong>11</strong></p>
<p>String stripTrailing()  <strong>11</strong></p>
<p>返回一个新字符串，这个字符串要删除原始原始字符串头部和尾部或者只是头部或尾部的空白符。要用这些方法而不是使用古老的trim方法删除小于等于U+0020的字符</p>
</li>
<li><p>String join(CharSequence delimiter,CharSequence… elements)  <strong>8</strong></p>
<p>返回一个新字符串，用给定的定界符连接所有元素</p>
</li>
<li><p>String repeat(int count)</p>
<p>返回一个字符串，将当前字符串重复count次</p>
</li>
</ul>
<blockquote>
<p>[!IMPORTANT]</p>
<p>在API注释中，有一些CharSequence类型的参数，这是一种接口类型，所有字符串都属于这种接口，当看到一个CharSequence形参（parameter)时，完全可以传入String类型的实参（argument)</p>
</blockquote>
<h3 id="3-6-8-联机API文档"><a href="#3-6-8-联机API文档" class="headerlink" title="3.6.8 联机API文档***"></a>3.6.8 联机API文档***</h3><p>类与方法数量过多，不可能全部记住，必须学会阅读联机API文档</p>
<p><a target="_blank" rel="noopener" href="https://docs.oracle.com/en/java/javase/17/docs/api/">Overview (Java SE 17 &amp; JDK 17)</a></p>
<h3 id="3-6-9-构建字符串"><a href="#3-6-9-构建字符串" class="headerlink" title="3.6.9 构建字符串"></a>3.6.9 构建字符串</h3><p>采用字符串拼接的方式将较短的字符串构建长字符串效率低，使用<em><strong>StringBuilder类</strong></em>可以避免此问题</p>
<pre><code class="language-java">StringBuilder builder = new StringBuilder();//构建一个空的字符串构建器
builder.append(ch);//appends a single character
builder.append(str);//appends a string
String completedString=builder.toString();//得到一个包含构建器中字符序列的String对象
</code></pre>
<blockquote>
<p>[!TIP]</p>
<p>StringBuffer类的效率不如StringBuilder类，但是它允许多线程的方式添加或删除字符串，如果所有字符串编辑都在单个线程中操作（通常情况），则应当使用StringBuilder类。这两个类的API是一样的</p>
</blockquote>
<p>java.lang.StringBuilder <strong>5</strong></p>
<ul>
<li><p>StringBuilder()</p>
<p>构造一个空的字符串构建器</p>
</li>
<li><p>int length()</p>
<p>返回构建器或缓冲器中的代码单元数量</p>
</li>
<li><p>StringBuilder append(String str)</p>
<p>追加一个字符串并返回this</p>
</li>
<li><p>StringBuilder append(char c)</p>
<p>追加一个代码单元并返回this</p>
</li>
<li><p>StringBuilder appendCodePoint(int cp)</p>
<p>追加一个码点，将它转换为一个或两个代码单元并返回this</p>
</li>
<li><p>void setCharAt(int i,char c)</p>
<p>将第i个代码单元设置为c</p>
</li>
<li><p>StringBuilder insert(int offset,String str)</p>
<p>在offset位置插入一个字符串并返回this</p>
</li>
<li><p>StringBuilder insert(int offset,char c)</p>
<p>在offset位置插入一个代码单元并返回this</p>
</li>
<li><p>StringBuilder delete(int startIndex,int endIndex)</p>
<p>删除从startIndex到endIndex-1的代码单元并返回this</p>
</li>
<li><p>String toString()</p>
<p>返回一个字符串，其数据与构建器或缓冲器内容相同</p>
</li>
</ul>
<h3 id="3-6-10-文本块"><a href="#3-6-10-文本块" class="headerlink" title="3.6.10 文本块"></a>3.6.10 文本块</h3><p>利用java15新增的文本块特性，可以很容易地提供跨多行的字符串字面量，<em><strong>文本块以”””开头，后面是一个换行符，并以另一个”””结束</strong></em></p>
<pre><code class="language-java">        String greeting= &quot;&quot;&quot;
                Hello
                World
                &quot;&quot;&quot;;
</code></pre>
<p>特点：易于读写</p>
<p>这个字符串有两个\n，一个在Hello后面，一个在World后面，<em><strong>开始”””后面的换行符不作为字符串字面量的一部分</strong></em></p>
<p>文本块很适合包含其他语言编写的代码，如SQL或HTML</p>
<pre><code class="language-java">        String html= &quot;&quot;&quot;
                &lt;div class=&quot;warning&quot;&gt;
                    Beware of those who say &quot;Hello&quot; to the world.
                &lt;/div&gt;
                &quot;&quot;&quot;;
</code></pre>
<p>只在以下两种对引号转义：</p>
<ol>
<li>文本块以一个引号结尾</li>
<li>文本块中包含三个或更多引号所组成的一个序列</li>
</ol>
<p><em><strong>所有反斜线\都需要转义</strong></em>，有一个转义序列只能在文本块中使用，<em><strong>行尾的\会把这一行与下一行连接起来</strong></em></p>
<pre><code class="language-java">String html= &quot;&quot;&quot;
                Hello,my name is lyh.\
                Please enter your name:&quot;&quot;&quot;;
</code></pre>
<p>文本块会对行结束符进行标准化，删除末尾的空白符，并把Windows 的行结束符(\r\n)改为简单的换行符(\n)。假如需要保留末尾的空格，请把最后一个空格转换为一个\s转义序列</p>
<pre><code class="language-java">		String html= &quot;&quot;&quot;
                &lt;div class=&quot;warning&quot;&gt;
                    Beware of those who say &quot;Hello&quot; to the world.
                &lt;/div&gt;
                &quot;&quot;&quot;;
</code></pre>
<p><em><strong>文本块将去除所有行的公共缩进</strong></em>，</p>
<p>实际字符串为”<div class="warning">\n	Beware of those who say “Hello” to the world.\n</div>\n”</p>
<p>去除缩进过程中不考虑空行，不过，结束”””前面的空白符很重要，一定要缩进到想要去除的空白符末尾</p>
<h2 id="3-6输入与输出"><a href="#3-6输入与输出" class="headerlink" title="3.6输入与输出"></a>3.6输入与输出</h2><p>简单介绍如何使用基本控制台来实现输入输出而非使用GUI</p>
<h3 id="3-7-1-读取输入"><a href="#3-7-1-读取输入" class="headerlink" title="3.7.1 读取输入"></a>3.7.1 读取输入</h3><p>要想读取控制台输入，<em><strong>首先要构造一个与“标准输入流”System.in关联的Scanner对象</strong></em>。</p>
<pre><code class="language-java">Scanner in=new Scanner(System.in);
</code></pre>
<p>然后使用Scanner类的各种方法读取输入，如nextLine方法将读取一行输入</p>
<pre><code class="language-java">String name=in.nextLine();
</code></pre>
<p>在这里<em><strong>使用nextLine方法是因为输入行中可能含有空格</strong></em>，要想读取一个单词（以空白符为分隔符），可以调用<em><strong>next</strong></em>方法</p>
<pre><code class="language-java">String firstName=in.next();
</code></pre>
<p>要想读取一个整数，使用<em><strong>nextInt</strong></em>方法</p>
<pre><code class="language-java">int age=in.nextInt();
</code></pre>
<p>类似地，使用<em><strong>nextDouble</strong></em>读取下一个浮点数</p>
<p><em><strong>Scanner类在java.util包中定义</strong></em>，使用请先导入(import)</p>
<p>扩展：util：utility package 工具包&#x2F;实用程序包</p>
<blockquote>
<p>[!CAUTION]</p>
<p>因为输入对所有人都可见，所以Scanner类不适用于从控制台读取密码，可以使用Console类打到读取密码的目的</p>
<pre><code class="language-java">Console cons=System.console();
String username=cons.readLine(&quot;Enter your name: &quot;);
char[] password=cons.readPassword(&quot;Enter your password: &quot;);
</code></pre>
<p>为什么使用字符数组char[]存储密码比使用字符串更安全？</p>
<p>一旦创建了一个String对象，它的内容就<em><strong>不能被修改</strong></em>，意味着，密码一旦被存储为String，它就会一直存在于内存中，直到被垃圾回收器（GC）回收,同时由于String是不可变的，Java 中的字符串常量池（String Pool）可能会<em><strong>永久保留</strong></em>这个密码，增加被恶意访问的风险。</p>
<p>完成对密码的处理后，应该马上用一个填充值覆盖数组元素。</p>
<p>使用Console对象处理输入不如使用Scanner来的方便，<em><strong>必须一次读取一行输入，而且Console类没有提供方法来读取单个单词或数字</strong></em></p>
</blockquote>
<p>java.util.Scanner <strong>5</strong> 常用方法</p>
<ul>
<li><p>Scanner(InputStream in)</p>
<p>用给定的输入流构造一个Scanner对象</p>
</li>
<li><p>String nextLine()</p>
<p>读取下一行输入</p>
</li>
<li><p>String next()</p>
<p>读取输入的下一个单词(以空白符为分隔符)</p>
</li>
<li><p>int nextInt()</p>
</li>
<li><p>double nextDouble()</p>
<p>读取并转换下一个表示整数或浮点数的字符序列</p>
</li>
<li><p>boolean hasNext()</p>
<p>检测输入中是否还有其他单词</p>
</li>
<li><p>boolean hasNextInt()</p>
</li>
<li><p>boolean hasNextDouble</p>
<p>检测下一个字符序列是否表示一个整数或一个浮点数</p>
</li>
</ul>
<p>java.lang.System <strong>1.0</strong></p>
<ul>
<li><p>static Console console() <strong>6</strong></p>
<p>如果有可能进行交互操作，就通过控制台窗口为交互的用户返回一个Console对象，否则返回null，对于任何一个在控制台窗口启动的程序，都可使用Console对象。否则，是否可用取决于使用的系统</p>
</li>
</ul>
<p>java.io.Console <strong>6</strong></p>
<ul>
<li><p>static char[] readPassword(String prompt,Object… args)（在命令行&#x2F;终端中使用不显示输入）</p>
</li>
<li><p>static String readLine(String prompt,Object… args)</p>
<p>显示提示符(prompt)并读取用户输入，直到输入行结束，可选的args参数用来提供格式参数</p>
</li>
</ul>
<h3 id="3-7-2格式化输出"><a href="#3-7-2格式化输出" class="headerlink" title="3.7.2格式化输出"></a>3.7.2格式化输出</h3><p>可以使用System.out.println(x)语句将数值x输出到控制台，这个命令将以x的类型所允许的最大非零位数打印x。可以使用printf方法解决某些格式问题</p>
<pre><code class="language-java">double x=10000.0/3.0;
System.out.printf(&quot;%8.2f&quot;,x);
</code></pre>
<p>打印x时字段宽度为8个字符，精度为2个字符，结果为” 3333.33”，包含一个前导空格</p>
<p>可以为printf提供多个参数</p>
<pre><code class="language-java">System.out.printf(&quot;Hello,%s.Next year,you&#39;ll be %d years old.\n&quot;,name,age);
</code></pre>
<p><em><strong>每一个以%开头的格式说明符都替换为相应的参数，格式说明符末尾的转换字符指示要格式化的数值的类型：f表示浮点数，s表示字符串，d表示十进制整数</strong></em></p>
<p>用于printf的转换字符如下</p>
<table>
<thead>
<tr>
<th>转换字符</th>
<th>类型</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>d</td>
<td>十进制整数</td>
<td>156</td>
</tr>
<tr>
<td>x或X</td>
<td>十六进制整数，要想对十六进制整数进行更多的操作，可以使用HexFormat类</td>
<td>9f</td>
</tr>
<tr>
<td>e</td>
<td>八进制整数</td>
<td>237</td>
</tr>
<tr>
<td>f或F</td>
<td>定点浮点数</td>
<td>15.9</td>
</tr>
<tr>
<td>e或E</td>
<td>指数浮点数</td>
<td>1.59e+01</td>
</tr>
<tr>
<td>g或G</td>
<td>通用浮点数（e和f中比较短的一个）</td>
<td>——</td>
</tr>
<tr>
<td>a或A</td>
<td>十六进制浮点数</td>
<td>0x1.fccdp3</td>
</tr>
<tr>
<td>s或S</td>
<td>字符串</td>
<td>Hello</td>
</tr>
<tr>
<td>c或C</td>
<td>字符</td>
<td>H</td>
</tr>
<tr>
<td>b或B</td>
<td>布尔</td>
<td>true</td>
</tr>
<tr>
<td>h或H</td>
<td>散列码</td>
<td>42628b2</td>
</tr>
<tr>
<td>tx或TX</td>
<td>遗留的日期时间格式化，应当改为java.time类</td>
<td>——</td>
</tr>
<tr>
<td>%</td>
<td>百分号（即%%&#x3D;%）</td>
<td>%</td>
</tr>
<tr>
<td>n</td>
<td>与平台有关的行分隔符</td>
<td>——</td>
</tr>
</tbody></table>
<p><em><strong>大写形式会生成大写字母</strong></em>，如”%8.2E”将3333.33格式化为3.33E+03</p>
<blockquote>
<p>[!NOTE]</p>
<p>可以使用s转换字符格式化任意的对象，如果一个任意对象实现了Formattable接口，格式化时调用这个对象的formatTo方法，否则，会调用toString方法将这个对象转换为一个字符串</p>
</blockquote>
<p>另外，还可以指定控制格式化输出外观的各种标志（flag）例如，逗号标志会增加分组分隔符</p>
<pre><code class="language-java">System.out.println(&quot;%,.2f&quot;，10000.0/3.0)；//打印3,333.33
</code></pre>
<p>可以使用多个标志，例如”%,(.2f”会使用分组分隔符，并将负数包围在括号内</p>
<table>
<thead>
<tr>
<th>标志</th>
<th>作用</th>
<th>示例</th>
</tr>
</thead>
<tbody><tr>
<td>+</td>
<td>打印正数或负数的符号</td>
<td>+3333.33</td>
</tr>
<tr>
<td>空格</td>
<td>在正数前面增加一个空格</td>
<td>| 3333.33|</td>
</tr>
<tr>
<td>0</td>
<td>增加前导0</td>
<td>003333.33</td>
</tr>
<tr>
<td>-</td>
<td>字段左对齐</td>
<td>|3333.33|</td>
</tr>
<tr>
<td>(</td>
<td>将负数包围在括号内</td>
<td>（3333.33）&#x3D;-3333.33</td>
</tr>
<tr>
<td>,</td>
<td>增加分组分隔符</td>
<td>3,333.33</td>
</tr>
<tr>
<td>#(对于f格式)</td>
<td>总是包含一个小数点</td>
<td>3,333.</td>
</tr>
<tr>
<td>#(对于x或0格式)</td>
<td>添加前缀0x或0</td>
<td>0xcafe</td>
</tr>
<tr>
<td>$</td>
<td>指定要格式化的参数索引，例如%1$x将以十六进制打印第一个参数</td>
<td>159 9F</td>
</tr>
<tr>
<td>&lt;</td>
<td>格式化前面指定的同一个值，%d&lt;%x将以十进制和十六进制打印同一个数</td>
<td>159 9F</td>
</tr>
</tbody></table>
<p>可以<em><strong>使用静态的String.format方法创建一个格式化的字符串而不打印输出</strong></em></p>
<pre><code class="language-java">String message=String.format(&quot;Hello,%s.Next year,you&#39;ll be %d years old.\n&quot;,name,age+1);
</code></pre>
<p>在Java15中，可以使用<em><strong>formatted</strong></em>方法</p>
<pre><code class="language-java">String message=&quot;Hello,%s.Next year,you&#39;ll be %d years old.\n&quot;.formatted(name,age+1);
</code></pre>
<p><img src="/.io//06/24/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E7%AB%A0/1/7.jpg" alt="7"></p>
<blockquote>
<p>[!CAUTION]</p>
<p><em><strong>格式化规则是特定于本地环境的</strong></em>，例如在德国分组分隔符是点号而不是逗号，因此要学习如何控制应用的国际化行为</p>
</blockquote>
<h3 id="3-7-3文件输入与输出"><a href="#3-7-3文件输入与输出" class="headerlink" title="3.7.3文件输入与输出"></a>3.7.3文件输入与输出</h3><p>要想读取一个文件，需要先构造一个Scanner对象</p>
<pre><code class="language-java">Scanner in=new Scanner(Path.of(&quot;myfile.txt&quot;), StandardCharsets.UTF_8);
</code></pre>
<p><em><strong>如果文件名中包含反斜线符号，要在每个反斜线符号之前加上一个额外的反斜线进行转义</strong></em></p>
<p>然后可以使用跟之前的任何Scanner方法读取文件</p>
<blockquote>
<p>[!NOTE]</p>
<p>上面指定了UTF-8字符编码，这对于互联网上的文件很常见，但并不一定完全适用，所以在读取一个文本文件时，要知道它的字符编码，若省略字符编码则会使用运行这个JAVA程序的机器的默认编码，这并不是是一个好主意，因为这会导致在不同的机器上运行这个程序可能会有不同的表现</p>
</blockquote>
<blockquote>
<p>[!WARNING]</p>
<p>可以提供一个字符串参数来构造一个Scanner，但这个Scanner会把字符串解析为数据而非文件名，例如</p>
<pre><code class="language-java">Scanner in=new Scanner(&quot;myfile.txt&quot;);
</code></pre>
<p>这个Scanner会将参数看作是包含十个字符的数据</p>
</blockquote>
<p><em><strong>要想写入文件，需要构造一个PrintWriter</strong></em></p>
<pre><code class="language-java">PrintWriter out = new PrintWriter(&quot;myfile.txt&quot;, StandardCharsets.UTF_8);
</code></pre>
<p>如果文件不存在，则会先创建该文件，可以像输出到System.out一样使用println、print、printf等命令</p>
<blockquote>
<p>[!NOTE]</p>
<p>当指定一个相对文件名时，例如”myfile.txt””..&#x2F;myfile.txt”,文件将相对于启动JAVA虚拟机的那个目录放置</p>
<p>如果从一个命令Shell执行一下命令启动程序</p>
<pre><code class="language-shell">java MyProg
</code></pre>
<p>启动目录就是命令shell的当前目录，不过如果使用集成开发环境，那么启动目录将由IDE（Integrated Development Environment）控制，可以使用下面的调用找到这个目录的位置</p>
<pre><code class="language-java">String dir=System.getProperty(&quot;user.dir&quot;);
</code></pre>
<p>如果觉得文件定位太麻烦，建议<em><strong>使用绝对路径</strong></em>，如”&#x2F;home&#x2F;me&#x2F;mydirectory&#x2F;myfile.txt”等（也可使用反斜线，但要注意转义）</p>
</blockquote>
<p>如果<em><strong>用一个不存在的文件构造一个Scanner，或者用一个无法创建的文件名构造一个PrintWriter，就会产生异常</strong></em>，JAVA编译器认为这些异常比”被零除”更严重</p>
<pre><code class="language-java">    public static void main(String[] args) throws IOException &#123;//处理异常
        Scanner out = new Scanner(Path.of(&quot;myfile.txt&quot;), StandardCharsets.UTF_8);
    &#125;
</code></pre>
<blockquote>
<p>[!CAUTION]</p>
<p>从命令shell启动一个程序时，可以利用shell的重定向语法将任意文件关联到System.in和System.out</p>
<pre><code class="language-java">java MyProg&lt;myfile.txt&gt;output.txt//将标准输入重定向到 myfile.txt 文件，同时将标准输出重定向到 output.txt 文件
</code></pre>
<p>这样就不用担心处理IOException异常了（Java程序本身不需要显式地处理这些IO异常。这是因为重定向是由shell处理的，而不是由Java程序直接处理的）</p>
</blockquote>
<p>java.util.Scanner <strong>5</strong></p>
<ul>
<li><p>Scanner(Path p,String encoding)</p>
<p>构造一个Scanner使用给定字符编码从给定路径读取数据</p>
</li>
<li><p>Scanner(String data)</p>
<p>构造一个Scanner从给定字符串读取数据</p>
</li>
</ul>
<p>java.io.PrintWriter <strong>1.1</strong></p>
<ul>
<li><p>PrintWriter(String fileName)</p>
<p>构造一个PrintWriter将数据写入指定文件</p>
</li>
</ul>
<p>java.nio.file.Path  </p>
<ul>
<li><p>static Path of(String pathname)  <strong>11</strong></p>
<p>由指定路径名构造一个Path</p>
</li>
</ul>
<h2 id="3-8控制流程"><a href="#3-8控制流程" class="headerlink" title="3.8控制流程"></a>3.8控制流程</h2><p>与任何程序设计语句一样，java支持使用<em><strong>条件语句和循环结构</strong></em>来控制流程</p>
<blockquote>
<p>[!NOTE]</p>
<p>Java的控制流程结构与C&#x2F;C++基本相同，只有很少几个例外。Java中没有goto语句，但break语句可以带标签，可以利用它从嵌套循环中跳出（C中可能就要使用goto语句了）。以及还有一种变形的for循环，有点类似于C++中基于范围的for循环和C#中的foreach循环</p>
</blockquote>
<h3 id="3-8-1块作用域"><a href="#3-8-1块作用域" class="headerlink" title="3.8.1块作用域"></a>3.8.1块作用域</h3><p><em><strong>块（即复合语句）由若干条Java语句组成，并用一对大括号括起来，块确定了变量的作用域，一个块可以嵌套在另一个块中</strong></em></p>
<p><em><strong>不能在嵌套的两个块中声明同名变量</strong></em></p>
<pre><code class="language-java">public static void main(String[] args)
&#123;
	int n;
	...
	&#123;
		int k;
        int n;//ERROR--can&#39;t redeclare n in inner block
        ...
	&#125;
&#125;
</code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>在C++中，可以在嵌套的块中重定义一个变量，在内层定义的变量会屏蔽在外层定义的变量，这就有可能带来编程错误，因此Java中不允许这样做</p>
</blockquote>
<h3 id="3-8-2条件语句"><a href="#3-8-2条件语句" class="headerlink" title="3.8.2条件语句"></a>3.8.2条件语句</h3><p>条件语句的形式为<em><strong>if(condition) statement</strong></em></p>
<p>其中statement可以是块语句</p>
<pre><code class="language-java">if(condition)
&#123;
	statement1
	statement2
	...
&#125;
</code></pre>
<p>更一般的条件语句 <em><strong>if(condition) statement1 else statement2</strong></em> 同样可以替换为块语句</p>
<p><em><strong>else子句与最邻近的if构成一组</strong></em></p>
<pre><code class="language-java">if(x&lt;=0)if(x==0) sign=0;else sign=-1;
</code></pre>
<p>else与第二个if配对，但建议使用大括号让代码更加清晰</p>
<pre><code class="language-java">if(x&lt;=0)&#123;if(x==0) sign=0;else sign=-1;&#125;
</code></pre>
<p>反复使用if…else if…也很常见</p>
<pre><code class="language-java">if()&#123;&#125;
else if()&#123;&#125;
else if()&#123;&#125;
...
else&#123;&#125;
</code></pre>
<h3 id="3-8-3-循环"><a href="#3-8-3-循环" class="headerlink" title="3.8.3 循环"></a>3.8.3 循环</h3><p><em><strong>while循环会在条件为true时反复执行一个（块）语句，如果开始时循环条件就为false，那么while循环一次也不执行</strong></em></p>
<p>如果希望循环体至少循环一次，需要使用do&#x2F;while循环将检测放到最后 <em><strong>do statement while(condition)</strong></em></p>
<p>这种循环先执行语句（块），然后再检查循环条件，如果条件为true，重复执行语句，然后继续检测，以此类推</p>
<p>示例程序1</p>
<pre><code class="language-java">import java.util.*;

/**
 * This program demonstrates a &lt;code&gt;while&lt;/code&gt; loop.
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */
public class Retirement
&#123;
   public static void main(String[] args)
   &#123;
      // read inputs
      Scanner in = new Scanner(System.in);

      System.out.print(&quot;How much money do you need to retire? &quot;);
      double goal = in.nextDouble();

      System.out.print(&quot;How much money will you contribute every year? &quot;);
      double payment = in.nextDouble();

      System.out.print(&quot;Interest rate in %: &quot;);
      double interestRate = in.nextDouble();

      double balance = 0;
      int years = 0;

      // update account balance while goal isn&#39;t reached
      while (balance &lt; goal)
      &#123;
         // add this year&#39;s payment and interest
         balance += payment;
         double interest = balance * interestRate / 100;
         balance += interest;
         years++;
      &#125;

      System.out.println(&quot;You can retire in &quot; + years + &quot; years.&quot;);
   &#125;
&#125;
</code></pre>
<p>示例程序2</p>
<pre><code class="language-java">import java.util.*;

/**
 * This program demonstrates a &lt;code&gt;do/while&lt;/code&gt; loop.
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */
public class Retirement2
&#123;
   public static void main(String[] args)
   &#123;
      Scanner in = new Scanner(System.in);

      System.out.print(&quot;How much money will you contribute every year? &quot;);
      double payment = in.nextDouble();

      System.out.print(&quot;Interest rate in %: &quot;);
      double interestRate = in.nextDouble();

      double balance = 0;
      int year = 0;

      String input;

      // update account balance while user isn&#39;t ready to retire
      do
      &#123;
         // add this year&#39;s payment and interest
         balance += payment;
         double interest = balance * interestRate / 100;
         balance += interest;

         year++;

         // print current balance
         System.out.printf(&quot;After year %d, your balance is %,.2f%n&quot;, year, balance);

         // ask if ready to retire and get input
         System.out.print(&quot;Ready to retire? (Y/N) &quot;);
         input = in.next();
      &#125;
      while (input.equals(&quot;N&quot;));
   &#125;
&#125;
</code></pre>
<h3 id="3-8-4-确定性循环"><a href="#3-8-4-确定性循环" class="headerlink" title="3.8.4 确定性循环"></a>3.8.4 确定性循环</h3><p>for循环语句是支持迭代的一种通用结构，它由一个计数器或类似的变量控制迭代次数，每次迭代后更新变量。</p>
<pre><code class="language-java">for(int i=1;i&lt;=10;i++)
	System.out.println(i);
</code></pre>
<p>for语句的第一部分通常是对计数器初始化，第二部分给出每次新一轮循环执行前要检测的循环条件；第三部分指定如何更新计数器，建议三个部分<em><strong>使用相同的计数器变量</strong></em>，否则可能循环晦涩难懂</p>
<blockquote>
<p>[!WARNING]</p>
<p>在循环中检测两个浮点数是否相等需要格外小心</p>
<pre><code class="language-java">for(double x=0;x!=10;x+=0.1)...
</code></pre>
<p>这个循环永远不会结束，由于存在舍入误差，可能永远无法达到精确的最终值，上述循环中由于0.1无法精确地用二进制表示，x将从9.99999999999998跳到10.0999999999998</p>
</blockquote>
<p>如果变量在for语句内部声明，就只能在循环体内使用，若希望在外部使用则需要在外部声明</p>
<p><em><strong>可以在不同的for循环中定义同名变量</strong></em></p>
<p>for循环只是while循环的一种简化形式</p>
<p>示例程序</p>
<pre><code class="language-java">import java.util.*;

/**
 * This program demonstrates a &lt;code&gt;for&lt;/code&gt; loop.
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */
public class LotteryOdds
&#123;
   public static void main(String[] args)
   &#123;
      Scanner in = new Scanner(System.in);

      System.out.print(&quot;How many numbers do you need to draw? &quot;);
      int k = in.nextInt();

      System.out.print(&quot;What is the highest number you can draw? &quot;);
      int n = in.nextInt();

      /*
       * compute binomial coefficient n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k)
       */

      int lotteryOdds = 1;
      for (int i = 1; i &lt;= k; i++)
         lotteryOdds = lotteryOdds * (n - i + 1) / i;

      System.out.println(&quot;Your odds are 1 in &quot; + lotteryOdds + &quot;. Good luck!&quot;);
   &#125;
&#125;
</code></pre>
<h3 id="3-8-5-多重选择：switch语句"><a href="#3-8-5-多重选择：switch语句" class="headerlink" title="3.8.5 多重选择：switch语句"></a>3.8.5 多重选择：switch语句</h3><p><em><strong>适用于处理同一个表达式的多个选项</strong></em></p>
<pre><code class="language-java">      String input=&quot;&quot;;
      switch(input.toLowerCase())
      &#123;
         case &quot;yes&quot;,&quot;y&quot;-&gt;
         	...
         case &quot;no&quot;,&quot;n&quot;-&gt;
         	...
         default -&gt;
         	...
      &#125;
</code></pre>
<p>switch的经典形式可以追溯到C语言</p>
<pre><code class="language-java">int chOice=...;
switch(choice)
&#123;
	case 1:
		...
		break;
	case 2:
		...
		break;
	...
	default://bad input
		...
		break;
&#125;
</code></pre>
<p>switch语句从与 选项值相匹配的case标签开始执行，直到遇到下一个break语句，或者执行到switch语句结束。如果没有匹配的case标签，则执行default子句（若有）。</p>
<blockquote>
<p>[!WARNING]</p>
<p>有可能会触发多个分支。如果忘记在一个分支末尾加上break语句，就会接着执行下一个分支，这很容易引发错误</p>
<p>为了检测这种问题，编译代码时可以加上-Xlint:fallthrough选项</p>
<pre><code class="language-shell">javac -Xlint:fallthrough Test.java
</code></pre>
<p>这样一来如果某个分支最后缺少一个break语句编译器就会给出一个警告</p>
<p>如果确实要使用这种直通式行为（执行多个分支），可以为其外围方法添加一个注解@SuppressWarnings(“fallthrough”)，就不会生成警告了（注解是为编译器或处理Java源文件或类文件的工具提供信息的一种机制）</p>
</blockquote>
<p>switch表达式没有直通式行为，但为了对称，Java14引入了有直通行为的switch表达式</p>
<p><em><strong>有直通行为的以冒号结束，无直通行为则以箭头结束，二者不能混用</strong></em></p>
<p><strong>表达式</strong></p>
<p>无直通行为</p>
<pre><code class="language-java">      int numLetters=switch(seasonName)
      &#123;
         case &quot;Spring&quot; -&gt;
         &#123;
           System.out.print(&quot;spring time!&quot;);//增加日志语句
           yield 6;//yield：终止执行，并生成表达式的值
         &#125;
         case &quot;Summer&quot;,&quot;Winter&quot;-&gt;5;
         case &quot;Fall&quot; -&gt;4;
         default -&gt; -1;
      &#125;;
</code></pre>
<p>有直通行为 </p>
<pre><code class="language-java">      int numLetters=switch(seasonName)
      &#123;
         case &quot;Spring&quot; :
         &#123;
           System.out.print(&quot;spring time!&quot;);
         &#125;
         case &quot;Summer&quot;,&quot;Winter&quot;:
            yield 5;
         case &quot;Fall&quot; :
            yield 4;
         default:
            yield -1;
      &#125;;
</code></pre>
<p><strong>语句</strong></p>
<p>无直通行为</p>
<pre><code class="language-java">      int numLetters;
      switch (seasonName)
      &#123;
         case &quot;Spring&quot;-&gt;
         &#123;
            System.out.print(&quot;spring time&quot;);
            numLetters=6;
         &#125;
         case &quot;Summer&quot;,&quot;Winter&quot;-&gt;
            numLetters=5;
         case &quot;Fall&quot;-&gt;
            numLetters=4;
         default -&gt; 
            numLetters=-1;
      &#125;
</code></pre>
<p>有直通行为</p>
<pre><code class="language-java">int numLetters;
switch (seasonName)
&#123;
   case &quot;Spring&quot;:
   &#123;
      System.out.print(&quot;spring time&quot;);
   &#125;
   case &quot;Summer&quot;,&quot;Winter&quot;:
      numLetters=5;
      break;
   case &quot;Fall&quot;:
      numLetters=4;
      break;
   default :
      numLetters=-1;
&#125;
</code></pre>
<p><em><strong>switch表达式必须为每个可能的case生成一个值（经常需要default），但是语句则不用</strong></em></p>
<blockquote>
<p>[!NOTE]</p>
<p>完全可以在switch表达式 的一个分支中抛出异常</p>
<pre><code class="language-java">default-&gt;throw new IllegalArgumentException(&quot;Not a valid season&quot;);
</code></pre>
</blockquote>
<blockquote>
<p>[!WARNING]</p>
<p><em><strong>switch表达式的关键在于生成一个值（或者产生一个异常而失败），不允许跳出表达式</strong></em></p>
<pre><code class="language-java">default-&gt;&#123;return -1；&#125;//Error
</code></pre>
<p><em><strong>不能在switch表达式中使用return，break，continue语句</strong></em></p>
</blockquote>
<p><em><strong>switch表达式优于switch语句</strong></em>，只有在确实需要直通式行为，或者必须为一个switch表达式增加语句时，才需要使用break或yield</p>
<h3 id="3-8-6中断控制流程的语句"><a href="#3-8-6中断控制流程的语句" class="headerlink" title="3.8.6中断控制流程的语句"></a>3.8.6中断控制流程的语句</h3><p>尽管Java的设计者将goto仍作为一个保留字，但实际上并不打算在语言中包含goto。通常使用goto会被认为是一种拙劣的编码风格，无限制地使用goto语句很容易导致错误，但在有些情况下偶尔使用goto跳出循环还是很有益处的。</p>
<h4 id="不带标签的break"><a href="#不带标签的break" class="headerlink" title="不带标签的break"></a>不带标签的break</h4><p>退出循环（最内层）</p>
<h4 id="带标签的break（与C-不同，新增）"><a href="#带标签的break（与C-不同，新增）" class="headerlink" title="带标签的break（与C++不同，新增）"></a>带标签的break（与C++不同，新增）</h4><p><em><strong>允许跳出多重嵌套的循环</strong></em>（有时希望跳出所有循环）</p>
<p><em><strong>标签必须放在你想跳出的最外层循环之前，并且紧跟一个冒号</strong></em></p>
<pre><code class="language-java">Scanner in=new Scanner(System.in);
int n;
read_data:
while(...)//this loop statement is tagged with the label
&#123;
	...
	for(...)//this inner loop is not labeled
    &#123;
    	System.out.print(&quot;...&quot;);
    	n=.in.nextInt();
    	if(n&lt;0)
    		break read_data;//break out of read_data loop
    	...
    &#125;
&#125;
//this statement is executed immediately after the label break
//即如果输入有误，执行带标签的break会跳转到带标签的语句块末尾
//与任何使用break语句的代码一样，接下来需要检测循环是正常退出的还是由于break提前退出
if(n&lt;0)//check for bad situation
&#123;
	//deal with bad situation
&#125;
else
&#123;
	//carry out normal situation
&#125;
</code></pre>
<p>实际上，<em><strong>可以将标签应用到任何语句</strong></em>，包括if语句或块语句。<em><strong>但只能跳出语句块，而不能跳入语句块</strong></em></p>
<h4 id="continue语句（不带标签）"><a href="#continue语句（不带标签）" class="headerlink" title="continue语句（不带标签）"></a>continue语句（不带标签）</h4><p><em><strong>将控制转移到最内层外围循环首部，如果在for循环中使用会跳转到for循环的更新部分</strong></em></p>
<h4 id="带标签的continue语句"><a href="#带标签的continue语句" class="headerlink" title="带标签的continue语句"></a>带标签的continue语句</h4><h2 id="3-9大数"><a href="#3-9大数" class="headerlink" title="3.9大数"></a>3.9大数</h2><p>使用java.math包中两个很有用的类：<em><strong>BigInteger</strong></em>和<em><strong>BigDecimal</strong></em>可以处理包含<em><strong>任意长度数字序列</strong></em>的数值，BigInteger实现任意精度的整数运算，BigDecimal类实现任意精度的浮点数运算</p>
<p>使用静态的<em><strong>valueOf</strong></em>方法可以将一个普通的数转换成大数</p>
<pre><code class="language-java">BigInteger a=BigInteger.valueOf(100);
</code></pre>
<p>对于更长的数，可以使用一个带字符串参数的构造器：</p>
<pre><code class="language-java">BigInteger reallyBig=new BigInteger(&quot;65659874454564561654165413146515614231685456212348954&quot;);
</code></pre>
<p>一些常量：<em><strong>BigInteger.ZERO,BigInteger.ONE,BigInteger.TEN</strong></em>,java 9之后还新增<em><strong>BigInteger.TWO</strong></em></p>
<blockquote>
<p>[!WARNING]</p>
<p>对于BigDecimal类，总是应当使用一个带字符串参数的构造器，还有一个BigDecimal（double）构造器，但是这个构造器本质上很<em><strong>容易产生舍入误差</strong></em>，例如new BigDecimal(0.1)会得到以下数位：0.1000000000000000055511151231257827021181583404541015625</p>
</blockquote>
<p>不能使用熟悉的算术运算符如+、*等来组合大数，而需要使用  <strong>大数类中的add和multiply方法</strong></p>
<pre><code class="language-java">BigInteger c=a.add(b);//c=a+b
BIgInteger d=c.mutiply(b.add(BigInteger.valueOf(2)));//d=c*(b+2)
</code></pre>
<blockquote>
<p>[!NOTE]</p>
<p>与C++不同，Java不能通过编程实现运算符重载，使用BigInteger类的程序员无法重定义+和*运算符来提供BigInteger类的add和mutiply运算。Java设计者重载了+运算符来完成字符串拼接，但没有重载其他运算符，也没有给Java程序员重载的机会</p>
</blockquote>
<p>示例程序</p>
<pre><code class="language-java">import java.math.*;
import java.util.*;

/**
 * This program uses big numbers to compute the odds of winning the grand prize in a lottery.
 * @version 1.21 2021-09-03
 * @author Cay Horstmann
 */
public class BigIntegerTest
&#123;
   public static void main(String[] args)
   &#123;
      Scanner in = new Scanner(System.in);

      System.out.print(&quot;How many numbers do you need to draw? &quot;);
      int k = in.nextInt();

      System.out.print(&quot;What is the highest number you can draw? &quot;);
      BigInteger n = in.nextBigInteger();

      /*
       * compute binomial coefficient n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k)
       */

      BigInteger lotteryOdds = BigInteger.ONE;

      for (int i = 1; i &lt;= k; i++)
         lotteryOdds = lotteryOdds
            .multiply(n.subtract(BigInteger.valueOf(i - 1)))
            .divide(BigInteger.valueOf(i));

      System.out.printf(&quot;Your odds are 1 in %s. Good luck!%n&quot;, lotteryOdds);
   &#125;
&#125;
</code></pre>
<p>java.math.BigInteger <strong>1.1</strong></p>
<ul>
<li><p>BigInteger add(BigInteger other)</p>
</li>
<li><p>BigInteger subtract(BigInteger other)</p>
</li>
<li><p>BigInteger mutiply(BigInteger other)</p>
</li>
<li><p>BigInteger divide(BigInteger other)</p>
</li>
<li><p>BigInteger mod(BigInteger other)</p>
<p>返回这个大整数和另一个大整数other的和、差、积、商和余数</p>
</li>
<li><p>BigInteger sqrt() <strong>9</strong></p>
<p>得到这个BigInteger的平方根</p>
</li>
<li><p>int compareTo(BigInteger other)</p>
<p>如果和另一个大整数other相等，返回0；如果小于other，返回负数；否则返回正数</p>
</li>
<li><p>static BigInteger valueOf(long x)</p>
<p>返回 值等于x的大整数</p>
</li>
</ul>
<p>java.math.BigDecimal <strong>1.1</strong></p>
<ul>
<li><p>BigDecimal(String digits)</p>
<p>用给定数位构造一个大实数</p>
</li>
<li><p>BigDecimal add(BigDecimal other)</p>
</li>
<li><p>BigDecimal subtract(BigDecimal other)</p>
</li>
<li><p>BigDecimal mutiply(BigDecimal other)</p>
</li>
<li><p>BigDecimal divide(BigDecimal other)</p>
</li>
<li><p>BigDecimal divide(BigDecimal other，RoundingMode mode)</p>
<p>返回这个大实数与另一个大实数other的和差积商。如果商是一个无限小数，第一个divide方法会抛出一个异常，要得到一个舍入的结果，就要使用第二个方法。RoundingMode.HALF_UP是四舍五入，其他舍入方法详见API文档</p>
</li>
<li><p>int compareTo(BigDecimal other)</p>
<p>如果和另一个大实数other相等，返回0；如果小于other，返回负数；否则返回正数</p>
</li>
</ul>
<h2 id="3-10数组"><a href="#3-10数组" class="headerlink" title="3.10数组"></a>3.10数组</h2><p>数组存储相同类型值的序列</p>
<h3 id="3-10-1-声明数组"><a href="#3-10-1-声明数组" class="headerlink" title="3.10.1 声明数组"></a>3.10.1 声明数组</h3><p>数组是一种数据结构，用来存储同一类型值的集合，通过一个整型下标（index）可以访问数组中的每一个值</p>
<pre><code class="language-java">int[] a;//声明数组
int[] a=new int[100];//or var a=new int[100];//初始化
</code></pre>
<p><em><strong>数组长度不要求是常数</strong></em>：new int[n]会创建一个长度为n的数组-&gt;根据n的当前值，并不会跟着n动态变化</p>
<p>一旦创建了数组，就不能再改变它的长度，如果程序运行过程中经常需要扩展数组的长度，就应该使用另一种数据结构——<em><strong>数组列表（array list）</strong></em></p>
<blockquote>
<p>[!TIP]</p>
<p>int[] a和int a[]均正确，但推荐使用int[] a,因为他可以将类型（整数数组）和变量名清晰地分开</p>
</blockquote>
<p>Java还提供了一种创建数组对象并提供初始值的简写形式,不需要new，也不需要指明数组长度</p>
<pre><code class="language-java">int[] Primes=&#123;2,3,5,7&#125;;
String[] authors=
&#123;
    &quot;nailong&quot;,
    &quot;James Gosling&quot;,
&#125;
</code></pre>
<p><em><strong>最后一个值后面允许有逗号</strong></em>，方便后续为数组增加值</p>
<p>可以使用以下语法<em><strong>重新初始化一个数组而无需创建新变量</strong></em></p>
<pre><code class="language-java">smallPrimes=new int[] &#123;2,3,5,7&#125;;
</code></pre>
<blockquote>
<p>[!IMPORTANT]</p>
<p>在Java中，允许有长度为0的数组，如果编写一个结果为数组的方法时碰巧结果为空，可以构造如下数组：</p>
<pre><code class="language-java">new elementType[0]//or new elementType[]&#123;&#125;
</code></pre>
<p><em><strong>长度为0的数组与null并不同</strong></em></p>
</blockquote>
<h3 id="3-10-2-访问数组元素"><a href="#3-10-2-访问数组元素" class="headerlink" title="3.10.2 访问数组元素"></a>3.10.2 访问数组元素</h3><p><em><strong>数组元素从0开始编号，最后一个合法索引为数组长度-1</strong></em></p>
<p><em><strong>创建一个数字数组时，所有元素都初始化为0；boolean数组的元素会初始化为false；对象数组（如字符串）的元素则初始化为一个特殊值null，表示还未存放任何对象</strong></em></p>
<blockquote>
<p>[!CAUTION]</p>
<p>C&#x2F;C++中若没有初始化数组可能为乱码</p>
</blockquote>
<p>如果创建一个包含一百个元素的数组然后访问a[100]就会出现”array index out of bounds”(数组索引越界)异常</p>
<p>要想获取数组中元素个数可以使用array.length</p>
<h3 id="3-10-3-for-each循环"><a href="#3-10-3-for-each循环" class="headerlink" title="3.10.3 for each循环"></a>3.10.3 for each循环</h3><p>增强的for循环形式（遍历数组而不用考虑指定索引值）</p>
<pre><code class="language-java">for(variable:collection)statement//循环collection中的每一个元素
</code></pre>
<p>variable：集合中的每一个元素</p>
<p>collection：数组或是一个实现了Iterable接口的对象（例如ArrayList）</p>
<p>优点:简洁；不易出错；不必考虑起始和终止索引值，避免越界访问</p>
<p>缺点：只能遍历整个数组；无法在循环内部使用索引值（此时使用传统for循环更佳）</p>
<blockquote>
<p>[!NOTE]</p>
<p>利用Arrays类中的toString方法可以更容易地打印数组中的所有值，调用Arrays.toString(a)会返回一个包含数组元素的字符串，这些元素包含在中括号中，并用逗号分隔，如”[2,3,5,7]”(并非逐个输出，而是整体输出)</p>
</blockquote>
<h3 id="3-10-4数组拷贝"><a href="#3-10-4数组拷贝" class="headerlink" title="3.10.4数组拷贝"></a>3.10.4数组拷贝</h3><p>在Java中，允许将一个数组变量拷贝到另一个数组变量，此时两个变量将<em><strong>引用同一个数组</strong></em>（指针）</p>
<pre><code class="language-java">int[] luckyNumbers=smallPrimes;
</code></pre>
<p><img src="/.io//06/24/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E7%AB%A0/1/8.jpg" alt="8"></p>
<p>如果只希望复制值，就要使用Arrays类的copyOf方法</p>
<pre><code class="language-java">int[] copiedLuckyNumbers=Arrays.copyOf(luckyNumbers,luckNumbers.length);//第二个参数为新数组长度
</code></pre>
<p>可以利用此方法来增加数组长度</p>
<pre><code>luckyNumbers=Arrays.copyOf(luckyNumbers,2*luckNumbers.length);
</code></pre>
<p><em><strong>如果数组元素是数值型，那么新增元素将填入0；如果是布尔型，填入false。如果新数组长度小于原数组，只拷贝前面的值。</strong></em></p>
<blockquote>
<p>[!CAUTION]</p>
<p>Java数组与堆栈上的C++数组有很大不同，但基本上与在堆上的分配的数组指针一样</p>
<p>也就是说</p>
<pre><code class="language-java">int[] a=new int[100];
</code></pre>
<p>不同于</p>
<pre><code class="language-c++">int a[100];
</code></pre>
<p>而等同于</p>
<pre><code class="language-c++">int* a=new int[100];
</code></pre>
<p><em><strong>Java中的[]运算符预定义为会完成越界检查（编写代码时便会出现越界警告）</strong></em>。另外，没有指针运算，意味着<em><strong>不能通过a+1得到数组中的下一个元素</strong></em></p>
</blockquote>
<h3 id="3-10-5-命令行参数"><a href="#3-10-5-命令行参数" class="headerlink" title="3.10.5 命令行参数"></a>3.10.5 命令行参数</h3><p><em><strong>String args[]表明main方法接受一个字符串数组，也就是命令行上指定的参数</strong></em></p>
<pre><code class="language-java">public class Message&#123;
   public static void main(String[] args)
   &#123;
   	if(args.length==0||args[0].equals(&quot;-h&quot;))
   		System.out.print(&quot;Hello,&quot;);
   	else if(args[0].equals(&quot;-g&quot;))
        System.out.print(&quot;Goodbye,&quot;);
    for(int i=1;i&lt;args.length;i++)
        System.out.print(&quot; &quot;+args[i]);
    System.out.println(&quot;!&quot;);
   &#125;
&#125;
</code></pre>
<p>如果如下调用程序</p>
<pre><code class="language-shell">java Message -g cruel world
</code></pre>
<p>args数组将包含以下内容：args[0]:”-g” args[1]:”cruel” args[2]:”world”</p>
<p>程序将会显示：Goodbye,cruel world!</p>
<blockquote>
<p>[!NOTE]</p>
<p>在Java程序的main方法中，程序名并不存储在args数组中，例如</p>
<pre><code class="language-shell">java Message -h world
</code></pre>
<p>args[0]是”-h”,而不是”Message”或者”java”</p>
</blockquote>
<h3 id="3-10-6-数组排序"><a href="#3-10-6-数组排序" class="headerlink" title="3.10.6 数组排序"></a>3.10.6 数组排序</h3><p>想对数值型数组排序可以使用Arrays类中的sort方法，这个方法使用了优化的<em><strong>快速排序</strong></em>算法</p>
<p>示例程序</p>
<pre><code class="language-java">import java.util.*;

/**
 * This program demonstrates array manipulation.
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */
public class LotteryDrawing
&#123;
   public static void main(String[] args)
   &#123;
      Scanner in = new Scanner(System.in);

      System.out.print(&quot;How many numbers do you need to draw? &quot;);
      int k = in.nextInt();

      System.out.print(&quot;What is the highest number you can draw? &quot;);
      int n = in.nextInt();

      // fill an array with numbers 1 2 3 . . . n
      int[] numbers = new int[n];
      for (int i = 0; i &lt; numbers.length; i++)
         numbers[i] = i + 1;

      // draw k numbers and put them into a second array
      int[] result = new int[k];
      for (int i = 0; i &lt; result.length; i++)
      &#123;
         // make a random index between 0 and n - 1
         int r = (int) (Math.random() * n);

         // pick the element at the random location
         result[i] = numbers[r];

         // move the last element into the random location
         numbers[r] = numbers[n - 1];
         n--;
      &#125;

      // print the sorted array
      Arrays.sort(result);
      System.out.println(&quot;Bet the following combination. It&#39;ll make you rich!&quot;);
      for (int r : result)
         System.out.println(r);
   &#125;
&#125;
</code></pre>
<p>其中Math.random方法将返回一个0到1之间（包含0而不包含1）的随机浮点数，用n乘以这个浮点数就可以得到从0到n-1的一个随机数</p>
<pre><code class="language-java">int r=(int)(Math.random()*n);
</code></pre>
<p>java.util.Arrays <strong>12</strong></p>
<ul>
<li><p>static String toString(xxx[] a) <strong>5</strong></p>
<p>返回一个字符串，其中包含a中的元素，这些元素用中括号包围。并用逗号分隔。在这个方法和后面 的方法中，数组元素类型xxx可以是int,long,short,char,byte,boolean,float,double</p>
</li>
<li><p>static xxx[] copyOf(xxx[] a,int end) <strong>6</strong></p>
</li>
<li><p>static xxx[] copyOfRange(xxx[] a,int start,int end) <strong>6</strong></p>
<p>返回与a类型相同的一个数组，其长度为end或end-start,并填入a中对应的值，如果end大于a.length,结果会填充0或false</p>
</li>
<li><p>static void sort(xxx[] a)</p>
<p>使用优化的快排算法排序</p>
</li>
<li><p>static int binarysearch(xxx[] a,xxx v)</p>
</li>
<li><p>static int binarysearch(xxx[] a,int start,int end,xxx v) <strong>6</strong></p>
<p>使用二分查找算法在<em><strong>有序数组</strong></em>a中查找值v，<em><strong>如果找到v,返回对应索引；否则返回一个负数值r,-r-1是v应该插入的位置</strong></em></p>
</li>
<li><p>static void fill(xxx[] a,xxx v)</p>
<p>将所有数组元素设置为v</p>
</li>
<li><p>static boolean equals(xxx[] a,xxx[] b)</p>
<p>如果两个数组长度相同且相同索引对应元素相同返回true</p>
</li>
</ul>
<h3 id="3-10-7多维数组"><a href="#3-10-7多维数组" class="headerlink" title="3.10.7多维数组"></a>3.10.7多维数组</h3><p>创建、初始化、访问与一维数组类似</p>
<blockquote>
<p>[!CAUTION]</p>
<p>for each循环语句不会自动循环处理二维数组的所有元素，他会循环处理行，而这些行本身是一维数组，要想访问二维数组a的所有元素，需要使用两个嵌套循环</p>
<pre><code class="language-java">for(double[] row:a)
	for(double value:row)
		do something with value
</code></pre>
</blockquote>
<blockquote>
<p>[!NOTE]</p>
<p>要想快速打印一个二维数组的元素列表，可以调用：</p>
<p>System.out.println(Arrays.deepToString(a));</p>
<p>输出格式为：</p>
<p>[[16,3,2,13],[5,10,11,8],[9,6,7,12],[4,15,14,1]]</p>
</blockquote>
<pre><code class="language-java">/**
 * This program shows how to store tabular data in a 2D array.
 * @version 1.41 2023-11-28
 * @author Cay Horstmann
 */
public class CompoundInterest
&#123;
   public static void main(String[] args)
   &#123;
      final double STARTRATE = 5;
      final int NRATES = 6;
      final int NYEARS = 10;

      // set interest rates to 5 . . . 10%
      double[] interestRate = new double[NRATES];
      for (int j = 0; j &lt; interestRate.length; j++)
         interestRate[j] = (STARTRATE + j) / 100.0;

      double[][] balances = new double[NYEARS][NRATES];

      // set initial balances to 10000
      for (int j = 0; j &lt; balances[0].length; j++)
         balances[0][j] = 10000;

      // compute interest for future years
      for (int i = 1; i &lt; balances.length; i++)
      &#123;
         for (int j = 0; j &lt; balances[i].length; j++)
         &#123;
            // get last year&#39;s balances from previous row
            double oldBalance = balances[i - 1][j];

            // compute interest
            double interest = oldBalance * interestRate[j];

            // compute this year&#39;s balances
            balances[i][j] = oldBalance + interest;
         &#125;
      &#125;

      // print one row of interest rates
      for (int j = 0; j &lt; interestRate.length; j++)
         System.out.printf(&quot;%9.0f%%&quot;, 100 * interestRate[j]);

      System.out.println();

      // print balance table
      for (double[] row : balances)
      &#123;
         // print table row
         for (double b : row)
            System.out.printf(&quot;%10.2f&quot;, b);

         System.out.println();
      &#125;
   &#125;
&#125;
</code></pre>
<h3 id="3-10-8-不规则数组"><a href="#3-10-8-不规则数组" class="headerlink" title="3.10.8 不规则数组"></a>3.10.8 不规则数组</h3><p><em><strong>Java实际上没有多维数组，只有一维数组，被解释为”数组的数组”</strong></em></p>
<p><img src="/.io//06/24/%E6%95%B0%E6%8D%AE%E7%AE%A1%E7%90%86%E5%9F%BA%E7%A1%80%E7%AC%AC%E4%B8%80%E7%AB%A0/1/9.jpg" alt="9"></p>
<p>由于可以单独地访问数组的某一行，所以可以让两行交换。</p>
<pre><code class="language-java">double[] temp =balance[i];
balance[i]=balance[i+1];
balance[i+1]=temp;
</code></pre>
<p>还可以构造一个不规则数组，即<em><strong>数组的每一行有不同的长度</strong></em></p>
<blockquote>
<p>[!CAUTION]</p>
<p>在C++中，Java声明</p>
<pre><code class="language-java">double[][] balances=new double[10][6];
</code></pre>
<p>不同于</p>
<pre><code class="language-c++">double balances[10][6];
</code></pre>
<p>也不同于</p>
<pre><code class="language-c++">double (*balances)[6]=new double[10][6];
</code></pre>
<p>而是分配了一个包含十个指针的数组</p>
<pre><code class="language-c++">double** balances=new double*[10];
</code></pre>
<p>这个指针数组的每一个元素会填充一个包含六个数字的数组</p>
<pre><code class="language-java">for(i=0;i&lt;10;i++)
	balances[i]=new double[6];
</code></pre>
<p>在需要不规则的数组时，需要单独地分配行数组</p>
</blockquote>
<p>示例程序</p>
<pre><code class="language-java">/**
 * This program demonstrates a triangular array.
 * @version 1.20 2004-02-10
 * @author Cay Horstmann
 */
public class LotteryArray
&#123;
   public static void main(String[] args)
   &#123;
      final int NMAX = 10;

      // allocate triangular array
      int[][] odds = new int[NMAX + 1][];
      for (int n = 0; n &lt;= NMAX; n++)
         odds[n] = new int[n + 1];

      // fill triangular array
      for (int n = 0; n &lt; odds.length; n++)
         for (int k = 0; k &lt; odds[n].length; k++)
         &#123;
            /*
             * compute binomial coefficient n*(n-1)*(n-2)*...*(n-k+1)/(1*2*3*...*k)
             */
            int lotteryOdds = 1;
            for (int i = 1; i &lt;= k; i++)
               lotteryOdds = lotteryOdds * (n - i + 1) / i;

            odds[n][k] = lotteryOdds;
         &#125;

      // print triangular array
      for (int[] row : odds)
      &#123;
         for (int odd : row)
            System.out.printf(&quot;%4d&quot;, odd);
         System.out.println();
      &#125;
   &#125;
&#125;
</code></pre>
<h1 id="第四章-对象与类"><a href="#第四章-对象与类" class="headerlink" title="第四章 对象与类"></a>第四章 对象与类</h1>
    </div>
    
    
    
    <div id="comment">
        <div id="gitalk-container"></div>
    </div>
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    <div id="comment">
        <div id="waline-container"></div>
    </div>
    
    
    <div id="comment">
        <div id="twikoo-container"></div>
    </div>
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 NJUShinchan&#39;s Nest
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Yonghong Lin
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>


    
    
<script
    src="https://giscus.app/client.js"
    data-repo=""
    data-repo-id=""
    data-category=""
    data-category-id=""
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang=""
    crossorigin
    async
></script>


<script>
    const gitalk = new Gitalk({
        clientID: "",
        clientSecret: "",
        repo: "",
        owner: "",
        admin: "".split(","),
        language: "",
        id: location.pathname,
        
    })
    gitalk.render("gitalk-container");
</script>


<script>
    Waline.init({
        el: "#waline-container",
        serverURL: "",
        commentCount: true,
        pageview: false,
        emoji: "https://unpkg.com/@waline/emojis@1.2.0/weibo,https://unpkg.com/@waline/emojis@1.2.0/alus,https://unpkg.com/@waline/emojis@1.2.0/bilibili,https://unpkg.com/@waline/emojis@1.2.0/qq,https://unpkg.com/@waline/emojis@1.2.0/tieba,https://unpkg.com/@waline/emojis@1.2.0/tw-emoji".split(","),
        meta: "nick,mail,link".split(","),
        requiredMeta: "nick".split(","),
        lang: "",
        wordLimit: 0,
        pageSize: "10",
        login: "enable",
        
    });
</script>


<script>
    twikoo.init({
        el: "#twikoo-container",
        envId: "",
        region: "",
        path: location.pathname,
        lang: "",
    })
</script>


    
</body>
</html>
<canvas
        id="fireworks"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>

<canvas
        id="background"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>

<link rel="stylesheet" href="/dist/APlayer.min.css">
<div id="aplayer"></div>
<script type="text/javascript" src="/dist/APlayer.min.js"></script>
<script type="text/javascript" src="/dist/music.js"></script>