
<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="utf-8" />
    <title>JAVA八股文 | NJUShinchan&#39;s Nest</title>
    <meta name="author" content="Yonghong Lin" />
    <meta name="description" content="And let your spirit dance with the world’s endless possibilities." />
    <meta name="keywords" content="" />
    <meta
        name="viewport"
        content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0"
    />
    <link rel="icon" href="/images/avatar.jpg" />
    <link rel="preconnect" href="https://s4.zstatic.net" />
<script src="https://s4.zstatic.net/ajax/libs/vue/3.3.7/vue.global.prod.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/font-awesome/6.4.2/css/all.min.css" />
<link rel="preconnect" href="https://fonts.googleapis.cn" />
<link rel="preconnect" href="https://fonts.gstatic.cn" crossorigin />
<link
    rel="stylesheet"
    href="https://fonts.googleapis.cn/css2?family=Fira+Code:wght@400;500;600;700&family=Lexend:wght@400;500;600;700;800;900&family=Noto+Sans+SC:wght@400;500;600;700;800;900&display=swap"
/>
<script> const mixins = {}; </script>

<script src="https://polyfill.alicdn.com/v3/polyfill.min.js?features=default"></script>


<script src="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/highlightjs-line-numbers.js/2.8.0/highlightjs-line-numbers.min.js"></script>
<link
    rel="stylesheet"
    href="https://s4.zstatic.net/ajax/libs/highlight.js/11.9.0/styles/github.min.css"
/>
<script src="/js/lib/highlight.js"></script>


<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.js"></script>
<script src="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/contrib/auto-render.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/KaTeX/0.16.9/katex.min.css" />
<script src="/js/lib/math.js"></script>


<script src="/js/lib/preview.js"></script>





<script src="https://s4.zstatic.net/ajax/libs/gitalk/1.8.0/gitalk.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/gitalk/1.8.0/gitalk.min.css" />


<script src="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.min.js"></script>
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline.min.css" />
<link rel="stylesheet" href="https://s4.zstatic.net/ajax/libs/waline/2.15.8/waline-meta.min.css" />


<script src="https://s4.zstatic.net/ajax/libs/twikoo/1.6.31/twikoo.all.min.js"></script>



<link rel="stylesheet" href="/css/main.css" />

<meta name="generator" content="Hexo 7.3.0"></head>
<body>
    <div id="layout">
        <transition name="fade">
            <div id="loading" v-show="loading">
                <div id="loading-circle">
                    <h2>LOADING</h2>
                    <p>加载过慢请开启缓存 浏览器默认开启</p>
                    <img src="/images/loading.gif" />
                </div>
            </div>
        </transition>
        <div id="menu" :class="{ hidden: hiddenMenu, 'menu-color': menuColor}">
    <nav id="desktop-menu">
        <a class="title" href="/">
            <span>NJUSHINCHAN&#39;S NEST</span>
        </a>
        
        <a href="/">
            <i class="fa-solid fa-house fa-fw"></i>
            <span>&ensp;Home</span>
        </a>
        
        <a href="/about">
            <i class="fa-solid fa-id-card fa-fw"></i>
            <span>&ensp;About</span>
        </a>
        
        <a href="/archives">
            <i class="fa-solid fa-box-archive fa-fw"></i>
            <span>&ensp;Archives</span>
        </a>
        
        <a href="/categories">
            <i class="fa-solid fa-bookmark fa-fw"></i>
            <span>&ensp;Categories</span>
        </a>
        
        <a href="/tags">
            <i class="fa-solid fa-tags fa-fw"></i>
            <span>&ensp;Tags</span>
        </a>
        
    </nav>
    <nav id="mobile-menu">
        <div class="title" @click="showMenuItems = !showMenuItems">
            <i class="fa-solid fa-bars fa-fw"></i>
            <span>&emsp;NJUSHINCHAN&#39;S NEST</span>
        </div>
        <transition name="slide">
            <div class="items" v-show="showMenuItems">
                
                <a href="/">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-house fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Home</div>
                    </div>
                </a>
                
                <a href="/about">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-id-card fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">About</div>
                    </div>
                </a>
                
                <a href="/archives">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-box-archive fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Archives</div>
                    </div>
                </a>
                
                <a href="/categories">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-bookmark fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Categories</div>
                    </div>
                </a>
                
                <a href="/tags">
                    <div class="item">
                        <div style="min-width: 20px; max-width: 50px; width: 10%">
                            <i class="fa-solid fa-tags fa-fw"></i>
                        </div>
                        <div style="min-width: 100px; max-width: 150%; width: 20%">Tags</div>
                    </div>
                </a>
                
            </div>
        </transition>
    </nav>
</div>
<transition name="fade">
    <div id="menu-curtain" @click="showMenuItems = !showMenuItems" v-show="showMenuItems"></div>
</transition>

        <div id="main" :class="loading ? 'into-enter-from': 'into-enter-active'">
            <div class="article">
    <div>
        <h1>JAVA八股文</h1>
    </div>
    <div class="info">
        <span class="date">
            <span class="icon">
                <i class="fa-solid fa-calendar fa-fw"></i>
            </span>
            2025/6/24
        </span>
        
        
    </div>
    
    <div class="content" v-pre>
        <p>JAVA常见知识点，是面试必考题</p>
<span id="more"></span>

<h1 id="Java"><a href="#Java" class="headerlink" title="Java"></a>Java</h1><h2 id="Java的特点"><a href="#Java的特点" class="headerlink" title="Java的特点"></a>Java的特点</h2><h3 id="Java是一门面向对象的编程语言"><a href="#Java是一门面向对象的编程语言" class="headerlink" title="Java是一门面向对象的编程语言"></a>Java是一门面向对象的编程语言</h3><h3 id="Java具有平台独立性和移植性"><a href="#Java具有平台独立性和移植性" class="headerlink" title="Java具有平台独立性和移植性"></a>Java具有平台独立性和移植性</h3><ul>
<li>Java有一句口号：write once , run anywhere，一次编写、到处运行。这正是Java的魅力所在。而实现这种特性的正是Java虚拟机JVM（Java Virtual Machine）。已编译的Java程序可以在任何带有JVM的平台上运行。如可在Windows平台编写代码，然后拿到Linux上运行。只要编写完代码后将代码编译成.class文件，再把class文件打成Java包，这个jar包就可以在不同的平台上运行了。</li>
</ul>
<h3 id="Java具有稳健性"><a href="#Java具有稳健性" class="headerlink" title="Java具有稳健性"></a>Java具有稳健性</h3><ul>
<li>Java是一个强类型的语言，它允许扩展编译时检查潜在类型不匹配问题的功能。Java要求显式的方法声明，它不支持C风格的隐式声明。这些严格要求保证编译程序能捕捉调用错误，保证更可靠的程序。</li>
<li>异常处理是Java中是程序更稳健的一个特征。异常是某种类似于错误的异常条件出现的信号。使用try&#x2F;catch&#x2F;finally语句，程序员可以找到出错的处理代码，这就简化了出错处理和恢复的任务。</li>
</ul>
<h2 id="Java是如何实现跨平台的？"><a href="#Java是如何实现跨平台的？" class="headerlink" title="Java是如何实现跨平台的？"></a>Java是如何实现跨平台的？</h2><p>Java通过JVM（Java虚拟机）实现跨平台。</p>
<p>JVM可以理解成一个软件，不同平台有不同版本。我们编写的Java代码，编译后会生成.class文件（字节码文件）。Java虚拟机就是负责将字节码文件翻译成特定平台下的机器码，通过JVM翻译成机器码之后才能运行。不同平台下编译生成的字节码是一样的，但是由JVM翻译成的机器码却不一样。</p>
<p>只要在不同平台上安装对应的JVM，就可以运行字节码文件，运行我们编写的Java程序。</p>
<p>因此，运行Java程序必须有JVM的支持，因为编译的结果不是机器码，必须经过JVM的翻译才能执行。</p>
<h2 id="Java与C-的区别"><a href="#Java与C-的区别" class="headerlink" title="Java与C++的区别"></a>Java与C++的区别</h2><ul>
<li>Java是纯粹的面向对象语言，所有的对象都继承自java.lang.object,C++兼容C，不但支持面向对象也支持面向过程。</li>
<li>Java通过虚拟机从而实现跨平台特性，C++依赖于特定平台。</li>
<li>Java没有指针，它的引用可以理解为安全指针，而C++具有和C一样的指针。</li>
<li>Java支持自动垃圾回收，而C++需要手动回收。</li>
<li>Java不支持多重继承(一个类同时继承多个类)，只能通过实现多个接口来达到相同目的，而C++支持多重继承。</li>
</ul>
<pre><code class="language-Java">// 定义两个接口
interface CanFly &#123;
    void fly();
&#125;

interface CanRun &#123;
    void run();
&#125;

// 定义一个实现这两个接口的类
class Duck extends Animal implements CanFly, CanRun &#123;
    public void fly() &#123;
        System.out.println(&quot;I can fly&quot;);
    &#125;

    public void run() &#123;
        System.out.println(&quot;I can run&quot;);
    &#125;
&#125;

// 定义父类
class Animal &#123;
    public void getCatagory() &#123;
        System.out.println(&quot;I&#39;m an animal&quot;);
    &#125;
&#125;

// 测试类
public class Test &#123;
    public static void main(String[] args) &#123;
        Duck d = new Duck();
        d.getCatagory(); // 继承自 Animal 类
        d.fly();        // 实现 CanFly 接口
        d.run();        // 实现 CanRun 接口
    &#125;
&#125;
#include &lt;iostream&gt;
using namespace std;

// 定义两个基类
class Worker &#123;
public:
    Worker(string name) : m_strName(name) &#123;
        cout &lt;&lt; &quot;Worker: &quot; &lt;&lt; m_strName &lt;&lt; endl;
    &#125;
    void work() &#123;
        cout &lt;&lt; m_strName &lt;&lt; &quot; is working&quot; &lt;&lt; endl;
    &#125;
protected:
    string m_strName;
&#125;;

class Singer &#123;
public:
    Singer(string song) : m_strSong(song) &#123;
        cout &lt;&lt; &quot;Singer: &quot; &lt;&lt; m_strSong &lt;&lt; endl;
    &#125;
    void sing() &#123;
        cout &lt;&lt; &quot;Singing &quot; &lt;&lt; m_strSong &lt;&lt; endl;
    &#125;
protected:
    string m_strSong;
&#125;;

// 定义派生类，继承自 Worker 和 Singer
class SingerWorker : public Worker, public Singer &#123;
public:
    SingerWorker(string name, string song) : Worker(name), Singer(song) &#123;&#125;
&#125;;

// 测试函数
int main() &#123;
    SingerWorker sw(&quot;Alice&quot;, &quot;Yesterday Once More&quot;);
    sw.work();  // 继承自 Worker
    sw.sing();  // 继承自 Singer
    return 0;
&#125;
</code></pre>
<h2 id="Java程序是编译执行还是解释执行？"><a href="#Java程序是编译执行还是解释执行？" class="headerlink" title="Java程序是编译执行还是解释执行？"></a>Java程序是编译执行还是解释执行？</h2><p>Java的源代码会通过javac(Java Compiler,编译器，.Java-&gt;.class)编译成字节码，然后再通过JVM将字节码转换成机器码执行，即解释执行和编译运行配合使用，可以成为混合型或者半编译型。</p>
<h3 id="编译型语言"><a href="#编译型语言" class="headerlink" title="编译型语言"></a>编译型语言</h3><p>在程序运行前，通过编译器将源程序编译成机器码可运行的二进制，以后执行这个程序时，就不用再进行编译了。</p>
<h4 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h4><p>编译器一般会有预编译的过程对代码进行优化，因为编译只做一次，运行时不需要编译，所以编译型语言的执行效率高，可以脱离语言环境独立运行。</p>
<h4 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h4><p>编译之后如果需要修改就需要整个模块重新编译。编译的时候根据对应的运行环境生成机器码，不同的操作系统之间移植就会有问题，需要根据运行的操作系统环境编译不同的可执行文件。</p>
<h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>运行速度快，效率高；依靠编译器，跨平台性差些</p>
<h4 id="代表语言"><a href="#代表语言" class="headerlink" title="代表语言"></a>代表语言</h4><p>C，C++，Pascal，Object-C,Swift</p>
<h3 id="解释型语言"><a href="#解释型语言" class="headerlink" title="解释型语言"></a>解释型语言</h3><p>解释型语言的源代码不是直接翻译成机器码，而是先翻译成中间代码，再由解释器对中间代码进行解释运行。在运行的时候才将程序翻译成机器码，翻译一句然后执行一句，直至结束。</p>
<h4 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h4><ol>
<li>有良好的平台兼容性，在任何环境中都可以运行，前提是安装了解释器（如虚拟机）。</li>
<li>灵活，修改代码的时候直接修改就可以，可以快速部署，不用停机维护。</li>
</ol>
<h4 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h4><p>每次运行的时候都要解释一遍，性能上不如编译型语言。</p>
<h4 id="总结-1"><a href="#总结-1" class="headerlink" title="总结"></a>总结</h4><p>解释型语言执行速度慢，效率低；依靠解释器，跨平台性好。</p>
<h4 id="代表语言-1"><a href="#代表语言-1" class="headerlink" title="代表语言"></a>代表语言</h4><p>JavaScript,Python,Erlang,PHP,Perl,Ruby</p>
<h2 id="JDK-JRE-JVM三者的关系"><a href="#JDK-JRE-JVM三者的关系" class="headerlink" title="JDK&#x2F;JRE&#x2F;JVM三者的关系"></a>JDK&#x2F;JRE&#x2F;JVM三者的关系</h2><h3 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h3><p>Java Development Kit Java开发工具包</p>
<p>JDK目录结构</p>
<p><img src="https://mcnw7sy6rg66.feishu.cn/space/api/box/stream/download/asynccode/?code=YjdkZDgyMjM2ODM1MzI3MmE5MmE1MTM5M2E2OGM4YThfWGZWSUJwR0JqY2VMbmVxQkd2RnFFU1pVQUxLTmhNd2NfVG9rZW46U2dldmJMbGJpb01xRXh4Y3daN2NzazFJbk5jXzE3NTA2OTk5MjU6MTc1MDcwMzUyNV9WNA" alt="img"></p>
<p>可以看到JDK目录下有JRE，即JDK中已经集成了JRE，不必单独安装JRE</p>
<p>另外，JDK中还有一些好用的工具，如jinfo，jps，jstack等。</p>
<h3 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h3><p>Java Runtime Environment Java运行时环境</p>
<p>我们编写的Java程序必须要在JRE才能运行，主要包含两部分：JVM和Java核心类库</p>
<p><img src="https://mcnw7sy6rg66.feishu.cn/space/api/box/stream/download/asynccode/?code=OTcwZGZkNmIwODllOTlhZGNjMTJjNGNiNWQyY2I1ZmZfUWIxeVJXblJheU91WGt6MVVPclBQRWpnbFVkYk55bDVfVG9rZW46WmVSWWJnMVNUb3dSUU14cUY2emNOdEJtbkQzXzE3NTA2OTk5MjU6MTc1MDcwMzUyNV9WNA" alt="img"></p>
<p>JRE是Java的运行环境，并不是一个开发环境，所以没有包含任何开发工具，如编译器和调试器等</p>
<p>如果只想运行Java程序而非开发Java程序的话，只需要安装JRE即可</p>
<h3 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h3><p>Java Virtual Machine Java虚拟机</p>
<p><img src="https://mcnw7sy6rg66.feishu.cn/space/api/box/stream/download/asynccode/?code=NDNkYWJlMmQ0MjdiNDFmMzk3MzY2NTdlMjFlYzYwMWZfY0F1VE5oZUNIaHlDMXprQTRUMXg3TWN5SFdUamxUM2pfVG9rZW46TkJJeGJnbjBzb3NMblJ4QlVJVmN3MTRrbkNlXzE3NTA2OTk5MjU6MTc1MDcwMzUyNV9WNA" alt="img"></p>
<p>所有的java程序会首先被编译为.class的类文件，这种类文件可以在虚拟机上执行。也就是说class文件并不直接与机器的操作系统交互，而是经过虚拟机间接与操作系统交互，由虚拟机将程序解释给本地系统执行。</p>
<p>针对不同的系统有不同的 jvm 实现，有 Linux 版本的 jvm 实现，也有Windows 版本的 jvm 实现，但是同一段代码在编译后的字节码是一样的。这就是Java能够跨平台，实现一次编写，多处运行的原因所在。</p>
<h3 id="总结-2"><a href="#总结-2" class="headerlink" title="总结"></a>总结</h3><p>JRE&#x3D;JVM+Java核心类库</p>
<p>JDK&#x3D;JRE+Java工具+编译器+调试器</p>
<h2 id="面向对象和面向过程的区别"><a href="#面向对象和面向过程的区别" class="headerlink" title="面向对象和面向过程的区别"></a>面向对象和面向过程的区别</h2><p>面向对象和面向过程是一种软件开发的思想。</p>
<ul>
<li>面向过程就是分析出解决问题所需要的步骤，然后用函数按这些步骤实现，使用的时候依次调用即可</li>
<li>面向对象是把构成问题的事务分解成各个对象，分别设计这些对象，然后将他们组装成有完整功能的系统。面向过程只用函数实现，面向对象是用类实现各个功能模块</li>
</ul>
<p>以五子棋为例</p>
<p>面向过程的设计思路就是首先分析问题的步骤：</p>
<p>1、开始游戏，2、黑子先走，3、绘制画面，4、判断输赢，5、轮到白子，6、绘制画面，7、判断输赢，8、返回步骤2，9、输出最后结果。 把上面每个步骤用分别的函数来实现，问题就解决了。</p>
<p>而面向对象的设计则是从另外的思路来解决问题。</p>
<p>整个五子棋可以分为：</p>
<p>1.黑白双方</p>
<p>2.棋盘系统，负责绘制画面</p>
<p>3.规则系统，负责判定诸如犯规、输赢等。</p>
<p>黑白双方负责接受用户的输入，并告知棋盘系统棋子布局发生变化，棋盘系统接收到了棋子的变化的信息就负责在屏幕上面显示出这种变化，同时利用规则系统来对棋局进行判定。</p>
<h2 id="面向对象有哪些特性？"><a href="#面向对象有哪些特性？" class="headerlink" title="面向对象有哪些特性？"></a>面向对象有哪些特性？</h2><p>封装、继承、多态、抽象</p>
<h3 id="封装"><a href="#封装" class="headerlink" title="封装"></a>封装</h3><p>封装就是把类的信息隐藏在类内部，不允许外部程序直接访问，而是通过该类的方法实现对隐藏信息的操作和访问。良好的封装能够减少耦合。</p>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>继承是从已有的类中派生出新的类，新的类继承父类的属性和行为，并能拓展新的能力，大大增加程序的重用性和易维护性。在Java中是单继承的，也就是说一个子类只会有一个父类。</p>
<h3 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h3><p>多态是同一个行为具有多个不同表现形式的能力。在不修改程序代码的情况下改变程序运行时绑定的代码。实现多态的三要素：继承、重写、父类引用指向子类对象。</p>
<h4 id="静态多态性"><a href="#静态多态性" class="headerlink" title="静态多态性"></a>静态多态性</h4><p>通过重载实现，相同的方法有不同的参数列表，可以根据参数的不同，做出不同的处理</p>
<h4 id="动态多态性"><a href="#动态多态性" class="headerlink" title="动态多态性"></a>动态多态性</h4><p>在子类中重写父类的方法。运行期间判断所引用对象的实际类型，根据其实际类型调用相应的方法。</p>
<h3 id="抽象"><a href="#抽象" class="headerlink" title="抽象"></a>抽象</h3><p>把客观事物用代码抽象出来。</p>
<h2 id="面向对象编程的六大原则"><a href="#面向对象编程的六大原则" class="headerlink" title="面向对象编程的六大原则"></a>面向对象编程的六大原则</h2><p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_34760445/article/details/82931002?ops_request_misc=%257B%2522request%255Fid%2522%253A%25221c521c62e184618a9691cf68adf80325%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&request_id=1c521c62e184618a9691cf68adf80325&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-7-82931002-null-null.142%5Ev102%5Epc_search_result_base8&utm_term=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99&spm=1018.2226.3001.4187">https://blog.csdn.net/qq_34760445/article/details/82931002?ops_request_misc=%257B%2522request%255Fid%2522%253A%25221c521c62e184618a9691cf68adf80325%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fall.%2522%257D&amp;request_id=1c521c62e184618a9691cf68adf80325&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_ecpm_v1~hot_rank-7-82931002-null-null.142^v102^pc_search_result_base8&amp;utm_term=%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%E7%BC%96%E7%A8%8B%E7%9A%84%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99&amp;spm=1018.2226.3001.4187</a></p>
<h3 id="对象单一职责：对象设计要求独立，不能设计万能对象"><a href="#对象单一职责：对象设计要求独立，不能设计万能对象" class="headerlink" title="对象单一职责：对象设计要求独立，不能设计万能对象"></a>对象单一职责：对象设计要求独立，不能设计万能对象</h3><p>设计创建的对象必须职责明确，比如商品类中相关的属性和方法都必须跟商品相关，不能出现订单等不相关的内容，这里的类可以是模块、类库、程序集，而不单单指类。</p>
<h3 id="里氏替换原则：程序扩展中抽象被具体可以替换（接口、父类、可以被实现类对象、子类替换对象）"><a href="#里氏替换原则：程序扩展中抽象被具体可以替换（接口、父类、可以被实现类对象、子类替换对象）" class="headerlink" title="里氏替换原则：程序扩展中抽象被具体可以替换（接口、父类、可以被实现类对象、子类替换对象）"></a>里氏替换原则：程序扩展中抽象被具体可以替换（接口、父类、可以被实现类对象、子类替换对象）</h3><p>子类能够完全替代父类，反之则不行。通常用于实现接口时运用。因为子类能够完全替代基类，那么这样父类就能拥有很多子类，在后续的程序扩展中就很容易进行扩展，程序完全不需要进行修改即可进行扩展。比如IA的实现为A，因为项目需求变更，现在需要新的实现，直接在容器注入处更换接口即可。</p>
<h3 id="迪米特法则：高内聚，低耦合。尽量不要依赖细节"><a href="#迪米特法则：高内聚，低耦合。尽量不要依赖细节" class="headerlink" title="迪米特法则：高内聚，低耦合。尽量不要依赖细节"></a>迪米特法则：高内聚，低耦合。尽量不要依赖细节</h3><p>也叫最小原则，或者说最小耦合。通常在设计程序或开发程序的时候，尽量要高内聚，低耦合。当两个类进行交互的时候，会产生依赖。而迪米特法则就是建议这种依赖越少越好。就像构造函数注入父类对象时一样，当需要依赖某个对象时，并不在意其内部是怎么实现的，而是在容器中注入相应的实现，既符合里式替换原则，又起到了解耦的作用。</p>
<h3 id="开闭原则：对象修改最小化"><a href="#开闭原则：对象修改最小化" class="headerlink" title="开闭原则：对象修改最小化"></a>开闭原则：对象修改最小化</h3><p>开放扩展，封闭修改。当项目需求发生变更时，要尽可能的不去对原有的代码进行修改，而在原有的基础上进行扩展。</p>
<h3 id="依赖倒置原则：面向抽象编程。也就是参数传递，或者返回值，可以使用父类类型或者接口类型。从广义上讲：基于接口编程，提前设计好接口框架"><a href="#依赖倒置原则：面向抽象编程。也就是参数传递，或者返回值，可以使用父类类型或者接口类型。从广义上讲：基于接口编程，提前设计好接口框架" class="headerlink" title="依赖倒置原则：面向抽象编程。也就是参数传递，或者返回值，可以使用父类类型或者接口类型。从广义上讲：基于接口编程，提前设计好接口框架"></a>依赖倒置原则：面向抽象编程。也就是参数传递，或者返回值，可以使用父类类型或者接口类型。从广义上讲：基于接口编程，提前设计好接口框架</h3><p>高层模块不应该直接依赖于底层模块的具体实现，而应该依赖于底层的抽象。接口和抽象类不应该依赖于实现类，而实现类依赖接口或抽象类</p>
<h3 id="接口隔离原则：接口设计大小要适中。过大导致污染，过小，导致调用麻烦"><a href="#接口隔离原则：接口设计大小要适中。过大导致污染，过小，导致调用麻烦" class="headerlink" title="接口隔离原则：接口设计大小要适中。过大导致污染，过小，导致调用麻烦"></a>接口隔离原则：接口设计大小要适中。过大导致污染，过小，导致调用麻烦</h3><p>一个对象和另外一个对象交互的过程中，依赖的内容最小。也就是说在接口设计的时候，在遵循对象单一职责的情况下，尽量减少接口的内容</p>
<h2 id="数组到底是不是对象？"><a href="#数组到底是不是对象？" class="headerlink" title="数组到底是不是对象？"></a>数组到底是不是对象？</h2><p>首先，什么是对象？对象是根据某个类创建出来的一个实例，表示某类事物中一个具体的个体。</p>
<p>对象具有各种属性，并且具有一些特定的行为。站在计算机的角度，对象就是内存中的一个内存块，在这个内存块封装了一些数据，也就是类中定义的各个属性。</p>
<p>所以，对象是用来封装数据的。</p>
<p>Java中的数组具有Java中其他对象的一些就基本特点。比如封装了一些数据，可以访问属性，也可以调用方法。</p>
<p>因此可以说数组是对象。</p>
<p>也可以通过代码验证数组是对象的事实。比如以下的代码，数组结果为java.lang.object。</p>
<pre><code class="language-Java">Class clz = int[].class;
System.out.println(clz.getSuperclass().getName());
</code></pre>
<p>由此可以看出数组类的父类就是Object类，那么可以推断出数组就是对象。</p>
<h2 id="Java的基本数据类型有哪些？"><a href="#Java的基本数据类型有哪些？" class="headerlink" title="Java的基本数据类型有哪些？"></a>Java的基本数据类型有哪些？</h2><ul>
<li>byte,8bit</li>
<li>char,16bit</li>
<li>short,16bit</li>
<li>int,32bit</li>
<li>float,32bit</li>
<li>long,64bit</li>
<li>double,64bit</li>
<li>boolean,只有两个值：true，false，可以使用1bit存储</li>
</ul>
<p><img src="https://mcnw7sy6rg66.feishu.cn/space/api/box/stream/download/asynccode/?code=YTQ2ZWRkNWYwMTc0ZTNmYzkxOWNmZTQ3ZGRmZmE1NzRfcmFpeGtQYWNlbzRRYTRKNkFGdDh5M2hyU2xzMnFObzVfVG9rZW46UGRVZ2JybE10bzdJWld4UHJIRWNsRk0xbm5iXzE3NTA2OTk5MjU6MTc1MDcwMzUyNV9WNA" alt="img"></p>
<p>在Java规范中，没有明确指出boolean的大小。在《Java虚拟机规范》给出了单个boolean占4个字节，和boolean数组1个字节的定义，具体 <strong>还要看虚拟机实现是否按照规范来</strong>，因此boolean占用1个字节或者4个字节都是有可能的。</p>
<h2 id="为什么不能用浮点型表示金额？"><a href="#为什么不能用浮点型表示金额？" class="headerlink" title="为什么不能用浮点型表示金额？"></a>为什么不能用浮点型表示金额？</h2><p>由于计算机中保存的小数其实是十进制的小数的近似值，并不是准确值，所以，千万不要在代码中使用浮点数来表示金额等重要的指标。</p>
<p>建议使用BigDecimal或者Long来表示金额。</p>
<p>e.g 0.1+0.2&#x3D;&#x3D;0.3 return false</p>
<h2 id="什么是值传递和引用传递？"><a href="#什么是值传递和引用传递？" class="headerlink" title="什么是值传递和引用传递？"></a>什么是值传递和引用传递？</h2><ul>
<li>值传递是对基本型变量而言的，传递的是该变量的一个副本，改变副本不影响原变量。</li>
<li>引用传递一般是对于对象型变量而言的，传递的是该对象地址的一个副本，并不是原对象本身，两者指向同一片内存空间。所以对引用对象进行操作会同时改变原对象。</li>
</ul>
<p>java中不存在引用传递，只有值传递。即不存在变量a指向变量b，变量b指向对象的这种情况。</p>
<h2 id="Java的包装类型是什么？为什么需要包装类？"><a href="#Java的包装类型是什么？为什么需要包装类？" class="headerlink" title="Java的包装类型是什么？为什么需要包装类？"></a>Java的包装类型是什么？为什么需要包装类？</h2><p>Java 是一种面向对象语言，很多地方都需要使用对象而不是基本数据类型。比如，在集合类中，我们是无法将 int 、double 等类型放进去的。因为集合的容器要求元素是 Object 类型。</p>
<p>为了让基本类型也具有对象的特征，就出现了包装类型。相当于将基本类型包装起来，使得它具有了对象的性质，并且为其添加了属性和方法，丰富了基本类型的操作。</p>
<h2 id="自动装箱和拆箱"><a href="#自动装箱和拆箱" class="headerlink" title="自动装箱和拆箱"></a>自动装箱和拆箱</h2><p><img src="https://mcnw7sy6rg66.feishu.cn/space/api/box/stream/download/asynccode/?code=YmUwZjAyNTUzMzFiMTk2NGQwMDkxYjJhZDkwOTk3MzVfTUVzMGoyWkpYc2NROWpwTXU4ZUJCUnJtTGRsb0pzTEZfVG9rZW46UTJEZ2JNUVhPb1FLWmV4dm84amM2SEszbkZmXzE3NTA2OTk5MjU6MTc1MDcwMzUyNV9WNA" alt="img"></p>
<p>装箱：将基础类型转化为包装类型。</p>
<p>拆箱：将包装类型转化为基础类型。</p>
<p>当基础类型与它们的包装类有如下几种情况时，编译器会<strong>自动</strong>帮我们进行装箱或拆箱：</p>
<ul>
<li>赋值操作（装箱或拆箱）</li>
<li>进行加减乘除混合运算 （拆箱）</li>
<li>进行&gt;,&lt;,&#x3D;&#x3D;比较运算（拆箱）</li>
<li>调用equals进行比较（装箱）</li>
<li>ArrayList、HashMap等集合类添加基础类型数据时（装箱）</li>
</ul>
<pre><code class="language-Java">Integer x = 1; // 装箱 调⽤ Integer.valueOf(1)
int y = x; // 拆箱 调⽤了 X.intValue()
</code></pre>
<h2 id="两个Integer用-比较不相等的原因"><a href="#两个Integer用-比较不相等的原因" class="headerlink" title="两个Integer用&#x3D;&#x3D;比较不相等的原因"></a>两个Integer用&#x3D;&#x3D;比较不相等的原因</h2><pre><code class="language-Java">Integer a = 100;
Integer b = 100;
System.out.println(a == b);
Integer c = 200;
Integer d = 200;
System.out.println(c == d);
</code></pre>
<p>输出：</p>
<pre><code class="language-Java">true
false
</code></pre>
<p>为什么第二个输出是false？看看 Integer 类的源码</p>
<pre><code class="language-java">public static Integer valueOf(int i) &#123;
    if (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)
        return IntegerCache.cache[i + (-IntegerCache.low)];
    return new Integer(i);&#125;
</code></pre>
<p><code>Integer c = 200;</code> 会调用<code>Integer.valueOf(200)</code>。而从Integer的valueOf()源码可以看到，这里的实现并不是简单的new Integer，而是用IntegerCache做一个cache。</p>
<pre><code class="language-Java">private static class IntegerCache &#123;
    static final int low = -128;
    static final int high;
    static final Integer cache[];
    static &#123;
        // high value may be configured by property
        int h = 127;
        String integerCacheHighPropValue =             sun.misc.VM.getSavedProperty(&quot;java.lang.Integer.IntegerCache.high&quot;);
        if (integerCacheHighPropValue != null) &#123;
            try &#123;
                int i = parseInt(integerCacheHighPropValue); 
                i = Math.max(i, 127);
                // Maximum array size is Integer.MAX_VALUE  
                h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
            &#125; catch( NumberFormatException nfe) &#123;
            // If the property cannot be parsed into an int, ignore it.
            &#125;
        &#125;         
        high = h;
     &#125;
     ...
&#125;
</code></pre>
<p>这是IntegerCache静态代码块中的一段，默认Integer cache 的下限是-128，上限默认127。当赋值100给Integer时，刚好在这个范围内，所以从cache中取对应的Integer并返回，所以a和b返回的是同一个对象，所以<code>==</code>比较是相等的，当赋值200给Integer时，不在cache 的范围内，所以会new Integer并返回，当然<code>==</code>比较的结果是不相等的。</p>
<p><img src="https://mcnw7sy6rg66.feishu.cn/space/api/box/stream/download/asynccode/?code=NmE1N2ViNDQxMWJmODQ4ZWRlNTQ0Zjk1ZWY0NjkyZGNfV1dHNm05WHd4UVZsdkVVWmFqd3BJdzV1MkZyaXBPQjlfVG9rZW46TkVVcWJ1OVdWb3lBMnp4N0NFY2NaZWlUbmloXzE3NTA2OTk5MjU6MTc1MDcwMzUyNV9WNA" alt="img"></p>
<h2 id="String为什么不可以变"><a href="#String为什么不可以变" class="headerlink" title="String为什么不可以变"></a>String为什么不可以变</h2><p>不可变对象：创建完成后无法再改变它的状态</p>
<p>不能改变状态：不能改变对象内的成员变量，包括基本数据类型的值不能改变，引用类型的变量不能指向其他的对象，引用类型指向的对象的状态也不能改变。</p>
<pre><code class="language-Java">public final class String
    implements java.io.Serializable, Comparable&lt;String&gt;, CharSequence &#123;
    /** The value is used for character storage. */
    private final char value[];
    /** Cache the hash code for the string */
    private int hash; 
    // Default to 0
&#125;
</code></pre>
<p>从源码可以看出，String对象其实在内部就是一个个字符，存储在这个value数组里面的。</p>
<p>value数组用final修饰，final 修饰的变量，值不能被修改。因此value不可以指向其他对象。</p>
<p>String类内部所有的字段都是私有的，也就是被private修饰。而且String没有对外提供修改内部状态的方法，因此value数组不能改变。</p>
<p>所以，String是不可变的。</p>
<p>那为什么String要设计成不可变的？</p>
<p>主要有以下几点原因：</p>
<ol>
<li><strong>线程安全</strong>。同一个字符串实例可以被多个线程共享，因为字符串不可变，本身就是线程安全的。</li>
<li><strong>支持hash映射和缓存</strong>。因为String的hash值经常会使用到，比如作为 Map 的键，不可变的特性使得 hash 值也不会变，不需要重新计算。</li>
<li><strong>出于安全考虑</strong>。网络地址URL、文件路径path、密码通常情况下都是以String类型保存，假若String不是固定不变的，将会引起各种安全隐患。比如将密码用String的类型保存，那么它将一直留在内存中，直到垃圾收集器把它清除。假如String类不是固定不变的，那么这个密码可能会被改变，导致出现安全隐患。</li>
<li><strong>字符串<strong><strong>常量池</strong></strong>优化</strong>。String对象创建之后，会缓存到字符串常量池中，下次需要创建同样的对象时，可以直接返回缓存的引用。</li>
</ol>
<p>既然我们的String是不可变的，它内部还有很多substring， replace， replaceAll这些操作的方法。这些方法好像会改变String对象？怎么解释呢？</p>
<p>其实不是的，我们每次调用replace等方法，其实会在堆内存中创建了一个新的对象。然后其value数组引用指向不同的对象。</p>
<p>实质：任何对String对象的修改操作（如拼接、截取等）都会返回一个新的String对象，而原始对象保持不变</p>

    </div>
    
    
    
    <div id="comment">
        <div id="gitalk-container"></div>
    </div>
    
    
    <div id="comment">
        <div id="giscus-container" class="giscus"></div>
    </div>
    
    
    <div id="comment">
        <div id="waline-container"></div>
    </div>
    
    
    <div id="comment">
        <div id="twikoo-container"></div>
    </div>
    
    
</div>

            <footer id="footer">
    <div id="footer-wrap">
        <div>
            &copy;
            2025 - 2025 NJUShinchan&#39;s Nest
            <span id="footer-icon">
                <i class="fa-solid fa-font-awesome fa-fw"></i>
            </span>
            &commat;Yonghong Lin
        </div>
        <div>
            Based on the <a target="_blank" rel="noopener" href="https://hexo.io">Hexo Engine</a> &amp;
            <a target="_blank" rel="noopener" href="https://github.com/theme-particlex/hexo-theme-particlex">ParticleX Theme</a>
        </div>
        
    </div>
</footer>

        </div>
        
        <transition name="fade">
            <div id="preview" ref="preview" v-show="previewShow">
                <img id="preview-content" ref="previewContent" />
            </div>
        </transition>
        
    </div>
    <script src="/js/main.js"></script>


    
    
<script
    src="https://giscus.app/client.js"
    data-repo=""
    data-repo-id=""
    data-category=""
    data-category-id=""
    data-mapping="pathname"
    data-strict="0"
    data-reactions-enabled="1"
    data-emit-metadata="0"
    data-input-position="bottom"
    data-theme="preferred_color_scheme"
    data-lang=""
    crossorigin
    async
></script>


<script>
    const gitalk = new Gitalk({
        clientID: "",
        clientSecret: "",
        repo: "",
        owner: "",
        admin: "".split(","),
        language: "",
        id: location.pathname,
        
    })
    gitalk.render("gitalk-container");
</script>


<script>
    Waline.init({
        el: "#waline-container",
        serverURL: "",
        commentCount: true,
        pageview: false,
        emoji: "https://unpkg.com/@waline/emojis@1.2.0/weibo,https://unpkg.com/@waline/emojis@1.2.0/alus,https://unpkg.com/@waline/emojis@1.2.0/bilibili,https://unpkg.com/@waline/emojis@1.2.0/qq,https://unpkg.com/@waline/emojis@1.2.0/tieba,https://unpkg.com/@waline/emojis@1.2.0/tw-emoji".split(","),
        meta: "nick,mail,link".split(","),
        requiredMeta: "nick".split(","),
        lang: "",
        wordLimit: 0,
        pageSize: "10",
        login: "enable",
        
    });
</script>


<script>
    twikoo.init({
        el: "#twikoo-container",
        envId: "",
        region: "",
        path: location.pathname,
        lang: "",
    })
</script>


    
</body>
</html>
<canvas
        id="fireworks"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: 32767"
></canvas>
<script src="https://s4.zstatic.net/ajax/libs/animejs/3.2.1/anime.min.js"></script>
<script src="/js/fireworks.min.js"></script>

<canvas
        id="background"
        style="position: fixed; top: 0; left: 0; width: 100vw; height: 100vh; pointer-events: none; z-index: -1"
></canvas>
<script src="/js/background.min.js"></script>

